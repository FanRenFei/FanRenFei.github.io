<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现存在重复]]></title>
    <url>%2F2018%2F12%2F05%2FJS%E5%AE%9E%E7%8E%B0%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 方法 1 排序后循环遍历先对数组进行排序，然后如果存在重复的数值，那么这几个数值一定是在一起的，也就是连续的，遍历的时候，只需要对该位置和该位置的后一个位置的数值进行比较就可以，两者相等，那么直接返回 true。遍历结束不存在，则返回 false12345678var containsDuplicate = function(nums) &#123; nums.sort() for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i + 1]) &#123; return true &#125; &#125; return false&#125;; 方法 2 哈希表哈希表特性我就不啰嗦，思路老套路：不存在就向表中存数据，存在返回值其实总结一些算法题：存在重复字眼的。都离不开哈希表(我说大多数啊 哈 毕竟我做的也不是很多啊。)考虑一下也无妨啊，搞不好一下子就出来了呢？123456789101112var containsDuplicate = function(nums) &#123; let hasObj = new Map() for (item of nums) &#123; if (hasObj.has(item)) &#123; return true &#125; else &#123; hasObj.set(item) &#125; &#125; return false&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
</search>
