<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一篇文章让你不再担心浮动]]></title>
    <url>%2F2018%2F12%2F27%2FHTML%2BCSS%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E4%B8%8D%E5%86%8D%E6%8B%85%E5%BF%83%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动的效果文档流文档流是文档中可显示对象在排列时所占用的位置。将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流.(自己的理解是从头到尾按照文档的顺序，该在什么位置就在什么位置，也可以按照上面的意思理解，自上而下，自左到右的顺序)浮动的特点使元素脱离文档流，按照指定的方向发生移动，遇到父级的边界或者相邻的浮动元素就会停下来 123456781 块元素可以在一行显示2 按照一个指定的方向移动，遇到父级的边界或者相邻的浮动元素就会停下来3 行内元素支持宽高(设置浮动以后就会变成块级元素)4 脱离文档流：1 指元素不在页面当中占位置 2 定位是完全脱离文档流 3 浮动不是完全脱离文档流5 块级元素的默认宽度会被改变(包裹性) 块元素不设置宽高，那宽高会自动变成所撑开的内容6 父级高度塌陷(破坏性)--&gt; 子元素浮动以后，那么父元素的高度就不会自动撑开7 换行不会被解析成空格--&gt;浮动后的元素就会脱离文档流了，那它就不属于文档流的结构了，所以换行和空格都和父级没关系如果高度不一致的情况下，想让他们按顺序排列就可以选择inline-block 浮动的目的为了达到自己的布局目的，让指定元素定位在指定位置，我们就需要用到浮动。包含块想知道浮动的详细内容就必须知道包含块的概念。浮动元素的包含块是其最近的块级祖先元素。如下 P 标签是 img 的包含块而 span 不是。定位也有包含块的概念12&lt;p&gt;&lt;img src=&quot;#&quot; style=&quot;float:left&quot;&gt;&lt;/p&gt;&lt;span&gt;&lt;img src=&quot;#&quot; style=&quot;float:left&quot;&gt;&lt;/span&gt; 控制浮动元素的规则（准确的说就是浮动元素的特性，并不是需要代码实现的内容）1 浮动元素的左或右外边界不能超过其包含块的左或右内边界123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:1px solid red ; padding: 10px; &#125; .box1&#123; width: 50px; height: 50px; background: red; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动(或右浮动)元素的右(左)外边界这个规则的好处：所有的浮动元素都是可见的，不会产生一个浮动元素与另一个浮动元素重叠 3 左(右)浮动元素的右(左)边界不会再其右(左)边右(左)浮动元素的左(右)外边界的右(左)边这个规则也是防止浮动元素产生重叠，父级元素的宽度只有 500px 两个浮动子元素一个浮动在左，一个浮动在右，他们的宽度都是 300px。这时候有浮动的元素就会想下浮动，避免产生重叠 4 浮动元素的顶端不能比之前(前一个浮动元素)或块级元素的顶端更高比如有 A,B,C 三个浮动元素，它们依次出现的次序是 A,B,C,假如 A 浮动元素与顶端的距离为 10px，那么 B 元素与顶端的距离就一定要大于 10px 比如 15px，那么 C 与顶端的距离就一定要大于 15px 5 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高 与 4 有点类似6 浮动元素必须尽可能高地防止7 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动的越远浮动的影响：1 背景不能显示由于浮动产生，如果对父级设置了 CSS background 背景 CSS 背景颜色 或 CSS 背景图片。但是父级元素不能被撑开，所以导致 CSS 背景不能显示。 2 边框不能撑开如果父级元素设置了 CSS 边框属性，子元素设置浮动，父级元素不能被撑开 3 margin padding 设置值不能正确显示由于浮动导致父子级之间设置的 css padding 和 css margin 属性的值不能正确表达，特别是上下边的 padding 和 margin 不能正确显示 4 块状元素，会钻进浮动元素的下面，被浮动元素所覆盖，像这样 5 行内元素，例如文字， 则会环绕在浮动元素的周围，为浮动元素留出空间，像这样 6 浮动元素的父元素坍缩, 像这样： 浮动解决的问题外边距重合问题如果其他元素与此元素(浮动元素)相邻(这表示水平相邻和垂直相邻)，而且这些元素也有外边距，那么这些外边距不会与浮动元素的外边距合并 —CSS 权威指南 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box2&#123; width: 100px; height: 100px; background: green; color: #fff; border: 3px solid #f00; margin-top: 25px; float: left; &#125; .box1&#123; width: 100px; height: 100px; background: green; color: #fff; border: 3px solid #f00; margin-bottom: 25px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浮动前 浮动后 清除浮动1234567891011121314151617181 clear 元素的某个方向上不能有浮动元素 取值：left 元素的左边不能有浮动的元素 right元素的右边不能有浮动的元素 bot 元素的两边都不能有浮动的元素2 给父级添加高度 有时候是不能给父级元素添加高度的，所以这个方法就用不了(父级元素没有高度的情况下)3 inline-block 和上一个效果一样 但是用来以后就没有办法居中4 overflow:hidden 如果子级元素有定位的话，并且这个定位超过了父级的范围，那样的话就看不到了，所以不能加和这个命令5 空标签 空标签是没有内容的，但是它的作用是用来清除浮动的。所以不符合行为，样式，结构分离的标准 （ie6下标签是有一个最小高度19px，解决后也会有2像素的偏差）6 br清除浮动 和上面一样7 after伪类清除浮动(目前最主流的方法) after-代表选择的元素的内容后面 after伪类的内容默认是一个行内元素 content 为设置的内容 第一种 clear原理：添加一个空 div，利用 css 提高的 clear:both 清除浮动，让父级 div 能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空 div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 200px; background: red; border: 1px solid black; &#125; .div1&#123; float: left; &#125; .div2&#123; float: right; &#125; /*1 clear: both; .div3&#123; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二种 父级设置高度 并不能真正清除浮动（看着像是）原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级 div 不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*2、给父级添加高度：没有从根本上解决浮动的问题*/ height: 100px; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第三种 inline-block12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*3、inline-block*/ display: inline-block; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第四种 overflow:hidden原理：必须定义 width 或 zoom:1，同时不能定义 height，使用 overflow:hidden 时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：不能和 position 配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用 position 或对 overflow:hidden 理解比较深的朋友使用。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*4、overflow:hidden;*/ overflow: hidden; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第四种的另外 overflow: auto; 但是如果超出产生滚动条第五种 空标签原理和 clear 一样 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!--&lt;!--5、空标签--&gt; &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第六种 br 标签123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!--6、br清除浮动--&gt; &lt;br clear=&quot;all&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果和上面一样 第七种 after原理：IE8 以上和非 IE 浏览器才支持:after，原理和方法 2 有点类似，zoom(IE 专有属性)可解决 ie6,ie7 浮动问题 （其他浏览器不用） 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少 CSS 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 1px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: blueviolet; float: left; color: #fff; &#125; /* * 7、after伪类清除浮动（现在最主流的方法） * */ .box:after&#123; content: &apos;这是伪类生成的内容&apos;; &#125; .clearfix&#123; *zoom:1; &#125; .clearfix:after&#123; content: &apos;&apos;; display: block; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent clearfix&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现 动态分区-首次适应算法和最佳适应算法]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E5%92%8C%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[实验目的 了解动态分区分配方式中使用的数据结构和分配算法，并进一步加深对动态分区存储管理方式及其实现过程的理解。 实验内容(1) 用 C 语言(不会 C 这里就用 JS 实现)分别实现采用首次适应算法和最佳适应算法的动态分区分配过程 alloc( )和回收过程 free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。 (2) 假设初始状态下，可用的内存空间为 640KB，并有下列的请求序列： 1234567891011•作业1申请130KB。•作业2申请60KB。•作业3申请100KB。•作业2释放60KB。•作业4申请200KB。•作业3释放100KB。•作业1释放130KB。•作业5申请140KB。•作业6申请60KB。•作业7申请50KB。•作业6释放60KB。 请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。 思路解析1 首先给大家介绍下首次适应算法和最佳适算法首次适应算法 首次适应算法从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 最佳适应算法 它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。 上面是百度百科给的定义，其实已经解释的很清楚了，我在这里给大家举一个例子。比如你有一个数组-&gt;[6,4,9,5,2,1],里面的数值分别代表空间吧，这时候你有一个物体，只需要占用 2 空间。这时候你使用这个算法，从 6 开始遍历，发现 6 大于你需要的空间，那么这个物体肯定是可以存放的，所以你就选用 6 来存储这个 2 空间的物体，然后 6 空间就会成 4 空间。其实这个 4 空间就算是一个碎片了如果你又来了一个需要 6 空间的物体，然后刚好 6 空间被你用了(只剩下一个 4 空间)，那么只好向下找。这个就是首次适应算法。如果你采用最佳适应算法，那么你需要 2 空间，它从 6 开始遍历，然后找到刚刚适合 2 空间的(或者是距离它并且能装下它的空间)2。这时候就把 2 空间给占用了。如果你需要 4 空间，那么 5 就会被占用，剩下 1 空间。它的缺点就是，会有很多的小碎片。2 切入正题 题目要求是两种方法来实现对这个作业的调度作业的调度有申请和释放，空间同时有空闲分区和占用的分区。这就意味着我们需要先定义两个方法和两个数组空间 firstaddress 是指该作业的首地址。 lastaddress 是该作业的末地址。 length 是指长度 123456789let UseQueue = []// 占用的分区let freeQueue = [&#123; firstAddress: 0, lastAddress: 640, length: 640&#125;]//空闲的分区 因为首先由640的空间function free(Progress)//释放过程function FirstFit(Progress)//首次适应算法 申请function BestFit(Progress)//最佳适应算法 申请 一共有 7 个作业，所以我们这里需要先定义一个作业类，然后创建 7 个作业对象 12345678910111213141516function PCB(ID, firstAddress, length, lastAddress, flag) &#123; this.ID = ID //进程的ID this.firstAddress = firstAddress //进程的首地址 this.length = length //进程的长度 this.lastAddress = lastAddress //进程的末地址 this.flag = flag //是否使用&#125;//定义七个进程 这里首地址都是0，因为没分配let one = new PCB(1, 0, 130, 0, &apos;false&apos;)let two = new PCB(2, 0, 60, 0, &apos;false&apos;)let three = new PCB(3, 0, 100, 0, &apos;false&apos;)let four = new PCB(4, 0, 200, 0, &apos;false&apos;)let five = new PCB(5, 0, 140, 0, &apos;false&apos;)let six = new PCB(6, 0, 60, 0, &apos;false&apos;)let seven = new PCB(7, 0, 50, 0, &apos;false&apos;) 先编写一个有用的排序算法，后面会用的到，是利用一个对象中的某个属性进行排序 12345function sortlastAddressy(field) &#123; return function(a, lastAddress) &#123; return a[field] - lastAddress[field]; &#125;&#125; 这里实现首次适应算法 Progress 就是指各个作业 比如 one 作业 上面已经定义了，每次进入一个作业首先对空闲队列里面的空间进行排序(按照首地址排，并不是按照空间的大小排序，按照空间大小排那就是最佳适应算法了)。然后对空闲队列进行遍历，找到第一个适应 Progress 长度的空间，然后分配给它。里面的各个参数我进入代码给你们解释，看代码！ 12345678910111213141516171819202122232425262728293031function FirstFit(Progress) &#123; Progress.flag = &quot;true&quot; let d //它用来记录每次是空闲区间中哪一块被使用，记录它的末地址 freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;));//利用首地址排序， for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break;//找到以后就退出循环，不在遍历 找到了还遍历个逑啊 &#125; &#125; /* firstaddress 是我在全局定义的一个变量，用来记录每次在空闲去 生成空闲块的首地址 比如200-400的空闲 然后作业需要100空间，这里的Progress.firstAddress都是0，因为没有 被分配，所以都是0，那么firstaddress=100 ，分配以后，剩下的空闲块的首地址就是100了 */ firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress)//当作业被申请以后，就要进入占用空间 /*定义空闲块的末地址，也就是被使用的空闲块的末地址，200-400 被占用100以后 400还是是末地址 剩下的就是300-400的空闲块/* let lastAddress = d let length = lastAddress - firstAddress //每次分配作业以后就把 空闲块装进空闲空间 freeQueue.push(&#123; firstAddress, lastAddress, length, &#125;)&#125; 这里实现最佳适应算法 这里和首次适应算法的流程一样，区别就是排序的时候，这里是使用长度排序，而不是首地址空闲区里面第一个就是长度就短了，那么每次遍历只需要从头开始，找到第一个适合自己的，就是那个最适合自己的空间，然后退出，发现自己太聪明了。 12345678910111213141516171819202122function BestFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;length&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125; 这里实现释放算法 每次释放，作业就不是调用状态，就把它的状态改为 false详细解析看代码 12345678910111213141516171819function free(Progress) &#123; Progress.flag = &apos;false&apos; //找到要释放的作业的位置 let index = UseQueue.indexOf(Progress) //把该作业删除 UseQueue.splice(index, 1) /* 同时记录该作业的首地址，末地址，长度 因为他们释放以后，他们占用的空间就会变成空闲的，把该空闲块放到空闲空间中 */ let firstAddress = Progress.firstAddress let lastAddress = Progress.firstAddress + Progress.length let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125; 这里实现对空闲空间的操作 里面的内容众多 for 循环，你先看的话，你肯定不明白什么意思，这里给你说下它的功能你就知道它的代码意思 。这里是因为空闲空间的要求，需要对空间内的碎片进行整合比如空闲空间有两个空闲块 分别是 100-200 200-300 你发现 第一块的末地址与第二块的首地址相同，你就需要把它们合并成为 100-300，这就就剩下一个长度为 200 的大的空闲块同时如果是 100-400 300-400 这样的空闲块 你需要把第一块给删除了，因为 100-300 被使用。这样就只剩下 300-400 一块空闲。 123456789101112131415161718192021222324252627282930function dealFreequeue(freeQueue) &#123; if (freeQueue.length &gt; 1) &#123; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].lastAddress &amp;&amp; i != j) &#123; if (freeQueue[i].firstAddress &gt; freeQueue[j].firstAddress) &#123; freeQueue.splice(j, 1) &#125; else &#123; freeQueue.splice(i, 1) &#125; &#125; &#125; &#125; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].firstAddress &amp;&amp; freeQueue[i] != undefined) &#123; freeQueue[i].lastAddress = freeQueue[j].lastAddress freeQueue[i].length = freeQueue[i].lastAddress - freeQueue[i].firstAddress freeQueue.splice(j, 1) break; &#125; &#125; &#125; &#125; freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); return freeQueue&#125; 定义七个作业的执行数组 index=1 表示作业申请 index=-1 表示作业释放 12345678910111213141516171819202122232425262728293031323334353637let runqueue = [&#123; index: 1, Progress: one &#125;, &#123; index: 1, Progress: two &#125;, &#123; index: 1, Progress: three &#125;, &#123; index: -1, Progress: two &#125;, &#123; index: 1, Progress: four &#125;, &#123; index: -1, Progress: three &#125;, &#123; index: -1, Progress: one &#125;, &#123; index: 1, Progress: five &#125;, &#123; index: 1, Progress: six &#125;, &#123; index: 1, Progress: seven &#125;, &#123; index: -1, Progress: six &#125;] 实现展示界面 1234567891011function show(freeQueue) &#123; let str = &quot;&quot; let str1 = &quot;&quot;; for (item of freeQueue) &#123; str = item.firstAddress + &quot; &quot; + item.lastAddress + &quot; &quot; + item.length + &quot;\n&quot; str1 += str &#125; console.log(&quot;首地址 末地址 长度&quot;) console.log(str1)&#125; 实现首次适应算法的执行函数 12345678910111213141516171819function FirstFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) FirstFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空闲的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125; 实现最佳适应算法的执行函数 1234567891011121314151617function BestFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) BestFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空间的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125; 调用函数 不使用哪一个算法，就把它注释掉 12//FirstFitMain(runqueue)BestFitMain(runqueue) 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/* * @Author: mikey.zhaopeng * @Date: 2018-12-08 00:20:04 * @Last Modified by: mikey.zhaopeng * @Last Modified time: 2018-12-08 00:20:04 */function PCB(ID, firstAddress, length, lastAddress, flag) &#123; this.ID = ID //进程的ID this.firstAddress = firstAddress //进程的首地址 this.length = length //进程的长度 this.lastAddress = lastAddress //进程的末地址 this.flag = flag //是否使用&#125;//定义七个进程let one = new PCB(1, 0, 130, 0, &apos;false&apos;)let two = new PCB(2, 0, 60, 0, &apos;false&apos;)let three = new PCB(3, 0, 100, 0, &apos;false&apos;)let four = new PCB(4, 0, 200, 0, &apos;false&apos;)let five = new PCB(5, 0, 140, 0, &apos;false&apos;)let six = new PCB(6, 0, 60, 0, &apos;false&apos;)let seven = new PCB(7, 0, 50, 0, &apos;false&apos;)let freeQueue = [&#123; firstAddress: 0, lastAddress: 640, length: 640&#125;]let UseQueue = []let firstAddress = 0 //function sortlastAddressy(field) &#123; return function(a, lastAddress) &#123; return a[field] - lastAddress[field]; &#125;&#125;function FirstFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length, &#125;)&#125;function free(Progress) &#123; Progress.flag = &apos;false&apos; let index = UseQueue.indexOf(Progress) UseQueue.splice(index, 1) let firstAddress = Progress.firstAddress let lastAddress = Progress.firstAddress + Progress.length let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125;function BestFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;length&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125;let runqueue = [&#123; index: 1, Progress: one &#125;, &#123; index: 1, Progress: two &#125;, &#123; index: 1, Progress: three &#125;, &#123; index: -1, Progress: two &#125;, &#123; index: 1, Progress: four &#125;, &#123; index: -1, Progress: three &#125;, &#123; index: -1, Progress: one &#125;, &#123; index: 1, Progress: five &#125;, &#123; index: 1, Progress: six &#125;, &#123; index: 1, Progress: seven &#125;, &#123; index: -1, Progress: six &#125;]function dealFreequeue(freeQueue) &#123; if (freeQueue.length &gt; 1) &#123; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].lastAddress &amp;&amp; i != j) &#123; if (freeQueue[i].firstAddress &gt; freeQueue[j].firstAddress) &#123; freeQueue.splice(j, 1) &#125; else &#123; freeQueue.splice(i, 1) &#125; &#125; &#125; &#125; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].firstAddress &amp;&amp; freeQueue[i] != undefined) &#123; freeQueue[i].lastAddress = freeQueue[j].lastAddress freeQueue[i].length = freeQueue[i].lastAddress - freeQueue[i].firstAddress freeQueue.splice(j, 1) break; &#125; &#125; &#125; &#125; freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); return freeQueue&#125;function FirstFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) FirstFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空闲的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125;function BestFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) BestFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空间的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125;function show(freeQueue) &#123; let str = &quot;&quot; let str1 = &quot;&quot;; for (item of freeQueue) &#123; str = item.firstAddress + &quot; &quot; + item.lastAddress + &quot; &quot; + item.length + &quot;\n&quot; str1 += str &#125; console.log(&quot;首地址 末地址 长度&quot;) console.log(str1)&#125;//FirstFitMain(runqueue)BestFitMain(runqueue) 给大家看下结果，这里就截几个图，并不是全部结果，就前三个]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现加一]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路：这道题我遇到的时候，我想到的第一个方法居然不是用算法，而是采用将数组转换为字符串，然后将字符串转换为数字然后进行加一操作。最后在反过来转换为数组首先讲这样的方法是肯定正确的，而且思路很清晰，但是它脱离的算法的根本，而且它有一个致命的缺点就是不能对包含很多元素的数组进行操作，这样会报错，它只能对小数组进行操作，那肯定是不符合题意的。随后我就上网找了关于这题的答案，不过网上给出的解析很模糊。我大概看了一下就把他们的想法给实现啦：首先数字加一会产生二种情况：1 数字不会产生进位 2 数字会产生进位（这里的进位是包含 9999+1=10000） 首先将 9999+1=10000 这种特殊情况给特殊对待，下面是代码：12345678910111213141516let index = 0; let arr = [] let len = digits.lengthfor (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; 这里数组会产生增加一位，所以我新建一个数组，来满足要求，第一种情况完成，这时候我们来分析第二种：这里会有二种：1+2=3(只是举个例子) 和 9+1=10(这个是进位的唯一情况)前者问题很好解决，只是单纯的在数组该位置的元素加一就可以，这时候就可以直接结束循环 。9+1=10 这种会进位 那么原数组的位置 10 就会变成 0 也就是(array[i]%10) 而且 array[i-1]会加一 这时候又会继续刚才的判断 1+2=3 或者 9+1=10；也就是只有遇到 9+1 的时候才会对数组元素继续遍历，下面是代码：1234567891011121314151617else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125; 详细代码 JS 实现1234567891011121314151617181920212223242526272829303132333435363738var plusOne = function(digits) &#123; let index = 0; let arr = [] let len = digits.length for (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125;&#125;;let arr = [2, 4, 9, 3, 9]let a = plusOne(arr)console.log(a)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现 使用动态优先权的进程调度算法模拟]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[实验目的 通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。 实验内容（1）用 C 语言来实现对 N 个进程采用动态优先权优先算法的进程调度。（2）每个用来标识进程的进程控制块 PCB 用结构来描述，包括以下字段： •••• 进程标识数 ID。•••• 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。•••• 进程已占用的 CPU 时间 CPUTIME。•••• 进程还需占用的 CPU 时间 ALLTIME。当进程运行完毕时，ALLTIME 变为 0。•••• 进程的阻塞时间 STARTBLOCK，表示当进程再运行 STARTBLOCK 个时间片后，将进入阻塞状态。•••• 进程被阻塞的时间 BLOCKTIME，表示已足赛的进程再等待 BLOCKTIME 个时间片后，将转换成就绪状态•••• 进程状态 START。•••• 队列指针 NEXT，用来将 PCB 排成队列。 （3）优先数改变的原则： •••进程在就绪队列中呆一个时间片，优先数加 1。•••进程每运行一个时间片，优先数减 3。 （4）假设在调度前，系统中有 5 个进程，它们的初始状态如下：1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY 详细的步骤和思路全部在代码注释中，保证你看一遍就知道代码的意思，阅读起来没有任何难度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//定义一个PCB对象function PCB(ID, Priority, Cputime, Alltime, Startblock, BlockTime, state) &#123; this.ID = ID //进程ID this.Priority = Priority //进程优先级 this.Cputime = Cputime //进程已占用的事件 this.Alltime = Alltime //进程需要占用的时间 this.Startblock = Startblock //进程需阻塞时间 this.BlockTime = BlockTime //进程阻塞的时间 this.state = state //进程状态&#125;//定义五个进程let One = new PCB(0, 9, 0, 3, 2, 3, &quot;Start&quot;)let Two = new PCB(1, 38, 0, 3, -1, 0, &quot;Start&quot;)let Three = new PCB(2, 30, 0, 6, -1, 0, &quot;Start&quot;)let Four = new PCB(3, 29, 0, 3, -1, 0, &quot;Start&quot;)let Five = new PCB(4, 0, 0, 4, -1, 0, &quot;Start&quot;) //就绪队列let readyqueue = [] //阻塞队列let blockqueue = [] //临时队列，存储初始队列let tempqueue = [] //执行完的队列let overqueue = [] //定义一个数组(队列)readyqueue = [One, Two, Three, Four, Five] //正在进行的进程let runProgress = new PCB() // 就绪队列优先权排序 /** * Sort的排序是按照队列各个元素的Priority(也就是优先权排队的) * 每次排完以后，优先权最大的在数组后面，这样每次运行主程序只需要 * 将最后一个拿出来就是要被运行的进程 * */function Sort(start) &#123; //sort函数 里面自己写一个函数，用来比较对象内的属性(默认的sort往往是不能够使用的) function sortBy(field) &#123; return function(a, b) &#123; return a[field] - b[field]; &#125; &#125; start.sort(sortBy(&quot;Priority&quot;)); return start&#125;//定义一个展示的界面function showWindow(start) &#123; let str1 = &apos;&apos; let str2 = &apos;&apos; let str3 = &quot;&quot; let str4 = &quot;&quot; let str5 = &quot;&quot; let str6 = &quot;&quot; let str7 = &quot;&quot; for (let i = 0; i &lt; start.length; i++) &#123; str1 = str1 + &quot; &quot; + start[i].ID; str2 = str2 + &quot; &quot; + start[i].Priority; str3 = str3 + &quot; &quot; + start[i].Cputime; str4 = str4 + &quot; &quot; + start[i].Alltime; str5 = str5 + &quot; &quot; + start[i].Startblock; str6 = str6 + &quot; &quot; + start[i].BlockTime; str7 = str7 + &quot; &quot; + start[i].state; &#125; console.log(&quot;------------------------------------------------&quot;) console.log(&quot;| ID &quot; + str1 + &quot; |&quot;) console.log(&quot;| Priority &quot; + str2 + &quot; |&quot;) console.log(&quot;| Cputime &quot; + str3 + &quot; |&quot;) console.log(&quot;| AllTime &quot; + str4 + &quot; |&quot;) console.log(&quot;| StackBlock &quot; + str5 + &quot; |&quot;) console.log(&quot;| BlockTime &quot; + str6 + &quot; |&quot;) console.log(&quot;| State &quot; + str7 + &quot; |&quot;) console.log(&quot;#################################################&quot;) showID(&quot;blockqueue&quot;, blockqueue) showID(&quot;overqueue&quot;, overqueue) console.log(&quot;------------------------------------------------&quot;)&#125;function showID(str1, arr) &#123; let str = &quot;&quot; for (let i = 0; i &lt; arr.length; i++) &#123; str += &quot; &quot; + arr[i].ID &#125; console.log(str1 + &quot;里面的进程有:&quot; + str)&#125;//阻塞队列更新/** * 阻塞队列的更新一共有两个参数，因为阻塞中的进程，如果他的阻塞时间(BlockTime)等于0 * 意味着它的阻塞时间已经到了，就需要到就绪队列中 * 进入就绪队列以后就要对就绪队列进行重新排序找出优先权最大的那个 */function blockqueueUpdata(blockqueue, readyqueue) &#123; if (blockqueue.length != 0) &#123; for (item of blockqueue) &#123; item.BlockTime-- if (item.BlockTime == 0) &#123; readyqueue.push(item) blockqueue.pop() readyqueue = Sort(readyqueue) break; &#125; &#125; &#125;&#125;//就绪队列更新/** * 对就绪队列的更新，需要明白最后一个进程是不能更新的 * 因为最后一个进程是优先权最大的那个，那个进程是正在运行的进程，严格意义上说它不算是就绪队列的 * 所以我们只需要对除了最后一个元素的其他元素进行优先权+1的操作 */function readyqueueUpdata(readyqueue) &#123; for (let i = 0; i &lt;= readyqueue.length - 2; i++) &#123; readyqueue[i].Priority++ &#125;&#125;//index记录运行个时间片let index = 0 //运行一个时间片function run(readyqueue) &#123; readyqueue = Sort(readyqueue) //运行之前 先对就绪队列排序 console.log(&quot;第&quot; + index + &quot;次&quot;) //这个地方展示的结果是每次运行前的结果，变化后的结构在下一次展示中能看到 showWindow(readyqueue) /*** * 每运行一次 正在运行的进程的优先权-3 所需时间片-1 已占用CPU时间+1 */ readyqueue[readyqueue.length - 1].Priority -= 3 readyqueue[readyqueue.length - 1].Alltime -= 1 readyqueue[readyqueue.length - 1].Cputime += 1 //运行完以后需要对就绪队列和阻塞队列进行更新 readyqueueUpdata(readyqueue) blockqueueUpdata(blockqueue, readyqueue) /*每次运行都需要把运行进程的的Startblock-1 Startblock=n表示 该进程在运行n个时间片就会进入阻塞队列 */ readyqueue[readyqueue.length - 1].Startblock -= 1 /*查看就绪队列最后一个(也就是刚刚执行完的优先权最大的那个进程) 他的时间片是否已经运行完了，如果他的Alltime==0 意味着它 运行结束，就可以进入结束队列，不需要在就绪队列呆着(不需要 进行任何操作，其他进程运行与它无关) */ if (readyqueue[readyqueue.length - 1].Alltime == 0) &#123; console.log(readyqueue[readyqueue.length - 1].ID) readyqueue[readyqueue.length - 1].state = &quot;Finish&quot; overqueue.push(readyqueue.pop()) &#125; // 谁的StartBlock==0 就意味该进程需要进入阻塞队列，不能在就绪队列呆着 //因为每次对StartBlock-1 都是对就绪队列最后一个进行操作，所以这个只需要比较最后一个 if (readyqueue.length &gt; 0) &#123; if (readyqueue[readyqueue.length - 1].Startblock == 0) &#123; readyqueue[readyqueue.length - 1].state = &quot;Block&quot; blockqueue.push(readyqueue.pop()) &#125; &#125; readyqueue = Sort(readyqueue) index++&#125;//主函数 k的取值我是随便选的 主要判断就是readyqueue.length//如果等于0就结束操作，你这k 可以为任何值(需要和while一样就行)function main(readyqueue) &#123; let k = 0 while (k &lt; 5) &#123; run(readyqueue) k = 0 if (readyqueue.length == 0) &#123; k = 5 &#125; &#125;&#125;main(readyqueue)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现从排序数组中删除重复项]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 112345给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 212345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法 1指针法，这种方法很容易理解。在函数中我定义了一个变量 i，它的初始位置是在 0，而后它与后面的元素进行比较，如果他与后面的元素不相同，那里指针指向下一位，然后在于比较的元素进行换位。如果相同，则定义一个变量来记录数量。当 for 循环结束以后，整个数组后面的 k 个元素全是重复的元素，那么把它们删除得到的数组就是所要求的数组12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if(nums.length==0) return 0; let i=0; let k=0; for(let j=1;j&lt;nums.length;j++) &#123; if(nums[j]!=nums[i]) &#123; i++; nums[i]=nums[j]; &#125; else &#123;k++&#125; &#125; nums.splice(nums.length-k,k) return i+1&#125;; 解法 2利用对象，hash。在遍历数组的时候，如果对象中不存在该数值，就把该数值存放带对象中，并且将元素添加到新数组中，如果存在，则直接跳过12345678910let arr = [] let hash = &#123;&#125; for (let i = 0; i &lt; nums.length; i++) &#123; if (!hash[nums[i]]) &#123; hash[nums[i]] = true arr.push(nums[i]) &#125; &#125; return arr;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现移动零]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明12必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 首先循环这个数组，将数组中所有不是 0 的数字，拿出来放到数组前面123456let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; 因为要保持原数组非零元素的相对顺序，所以每当遇到一个不为 0 的变量都要进行复制！最后遍历结束，那么会有 K 个不为 0 的变量，随后的 nums.length-K 的长度都是 0下面是详细代码123456789101112var moveZeroes = function(nums) &#123; let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; for (let j = k; j &lt; nums.length; j++) &#123; nums[j] = 0; &#125; return nums&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现买股票的最佳时机]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 123456789101112131415161718示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 买卖股票问题就是典型的动态规划问题。把大问题分解成小问题，小问题的最优解求出来，合并就是大问题的最优解。这道题的小问题就是比较相邻两天的股票的高低，后面的一天比前面的一天股票高，我们就买出，这样就能赚到钱，把所有的问题都归结于二天股票高低，这样问题就很容易理解，我们可以举个例子123456输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出,这笔交易所能获得利润 = 6-3 = 3 。 关于这道题，要想解答出来我们首先需要搞清楚规则。买股票想要获取最大利润，那么我们首先需要先检查数组中第一个数字，也就是说第一天的价格是 7，第二天价格是 1，很明显我们不会在最贵的时候买股票。所以我们最开始在第二天买，也就是价格等于 1 的时候买，第三天价格变成了 5，说明有钱赚了，那么就马上卖掉。这时候利润就是=5-1=4然后我们在第四天价格等于 3 的时候买股票，第五天价格等于 6，有钱赚，那么就马上卖掉即可。这时候利润就是=6-3=3总利润就是 4+3=7 由此我们可以得出结论，当明天的价格比今天的价格贵的时候我们今天买，明天卖，这样能够获取最大利润。搞清楚这个，相信你对上面的算法就一目了然了 最简单的公式就是 0-1+5-3+6=7 当后者比前面大，我们就加，反之我们就减，最后没有-4 的原因是，减去以后就不是最大利润。最前面的 0 我们可以理解问我们没有钱，然后欠钱买第二天的股票。1234567let max = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; max += (prices[i + 1] - prices[i]) &#125; &#125; return max 我看啦很多网上的文章，思路都是我这样，我在写这篇博客的时候，就陷入误区，就是买股票的钱是从哪里来的？难道不是从利润中减去的吗？比如上面的那个例子:7 1 5 3 6 4我们在第二天花一元买了彩票，在第三天五块抛出，这时候你手里有五元，利润是 5-1=4。但是你还需要买这天的股票(这时候需要比较这天(抛出的这天)和它后面的那天的大小，如果他小，就买，大的话就别买)。你发现今天是五元明天确实三元，所以你就明天买，今天不买。因为你手里有 5 元，买下 3 元以后，你还有 2 元，然后在 6 元的那天抛出，这时候你手里的前一共是 6+2=8 元！因为你最开始买彩票花了 1 元，减去 1–&gt;8-1=7 元上面的那个问题是我在写博客的时候发现的，顿时就陷入误区，同时又是在写的过程中发现如何解决的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现字符串中的第一个唯一字符]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 代码：这道题读完以后就应该知道，这道题的时间复杂度最小也是 O(n),因为只要遍历玩整个字符串你才能知道那个字符串才是第一个不重复的字符串。思路：不存在返回-1 存在返回对应索引，那么就先把这二种情况分开：1 第一种 不存在返回 0 分为二种 空字符串 “” 和 “aabb” 空字符串在算法的开始进行一次判断就可以解决。第二种“aabb” 我们把它归到第二种情况下进行判断。2 第二种，我们只需设置一个对象 hashObj 在遍历字符串的时候，判断 hashObj 里面是否存在这个字符，如果不存在，就把这个位置的索引+1 放进去(为什么是加 1 因为第一个字符肯定不存在对象中，那么对象就会保存 0 这个索引，然而索引 0 在下一次判断的时候 Boolean 会把它转换为 fasle，那么他就会不存在，那么这个字符就会被重新赋值)如果存在就把该位置的值改为-2(-2 或者其他都行，-2 在这里只是表示这个字符重复的标志而已，但是那些会让判断变为 false 的值不可以)。遍历结束以后，这时候对 hashObj 进行遍历，找到第一个不是-2 的值 ，返回该值就是索引12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function(s) &#123; let hashObj = &#123;&#125; let b //存入索引 if (s == &quot;&quot;) &#123; b = -1 &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (hashObj[s[i]] &amp;&amp; hashObj[s[i]] != -2) &#123; hashObj[s[i]] = -2 &#125; else if (hashObj[s[i]] != -2) &#123; hashObj[s[i]] = i + 1 &#125; &#125; for (let item in hashObj) &#123; if (hashObj[item] != -2) &#123; b = (hashObj[item]) - 1 break; &#125; else &#123; b = -1 &#125; &#125; return b&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现有效的字母异位词]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 112输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 212输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 方法 1 类似哈希(还是重复问题)首先需要明白题的意思，其实就是比较两个字符串中字母是否相同，在相同的情况下比较该字符的数目是否相等。函数中先判断两个字符串的长度是否相等，不相等，直接返回 false 就不需要进行下面的操作定义两个对象,对象里面的变量格式在这里我就表示一下啊 哈1let obj=&#123;A:a&#125; 分别对两个字符串进行遍历(O(n)的时间复杂度)，如果对象不存在，则添加该单个字符，并将它的数值设置为 1。存在的话，就把他的数值加 1将对象转换为数组，进行数组长度的循环(这里为什么要把对象转换为数组，其实就是得到他的长度啊 哈)然后对数组进行遍历，然后将两个对象内对应数组遍历的值，进行比较。如果他们不同(说明某个字符，在两个字符串中出现的长度并不相等)直接返回 false12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; if (s.length != t.length) &#123; return false &#125; else if (s.length == 0 &amp;&amp; t.length == 0) &#123; return true &#125; else &#123; let sObj = &#123;&#125; let tObj = &#123;&#125; for (let i = 0; i &lt; s.length; i++) &#123; if (sObj[s[i]]) &#123; sObj[s[i]]++ &#125; else &#123; sObj[s[i]] = 1 &#125; &#125; for (let i = 0; i &lt; t.length; i++) &#123; if (tObj[t[i]]) &#123; tObj[t[i]]++ &#125; else &#123; tObj[t[i]] = 1 &#125; &#125; let arr = Object.keys(tObj) for (let i = 0; i &lt; arr.length; i++) &#123; if (tObj[arr[i]] != sObj[arr[i]]) &#123; return false &#125; &#125; return true &#125;&#125;; 方法 2 排序sort 方法可以对字符按照编码排序123d,c,b,a排完序以后a,b,c,d 思路很简单哦：先把字符串是 s,t 用字符串转换为数组 a,b(split 怎么用，自己看 API)。然后先看他们长度一样不，不一样就没必要进行下面的操作。一样的话，就对他们进行排序，排完序。a 和 b 两个数组是相等的(不是相同因为，内存地址不同)。那么进行循环，相同位置上的数它们都应该相等。不相等直接返回 false12345678910111213141516var isAnagram = function(s, t) &#123; let a = s.split(&quot;&quot;) let b = t.split(&quot;&quot;) if (a.length == b.length) &#123; a.sort() b.sort() for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] != b[i]) &#123; return false &#125; &#125; return true &#125; return false&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现只出现一次的数字]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 1234567示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 解法 1 暴力破解暴力破解的前提是你的数组是有序的，不是有序的，你遍历整个数组，你是无法进行比较的。在函数的开始，我就使用 JS 自带的 sort 排序进行排序(sort 使用的是插入排序和快速排序结合的排序算法。数组长度不超过 10 时，使用插入排序。长度超过 10 使用快速排序。在数组较短时插入排序更有效率。)遍历时候的时间复杂度是 O(lgN)的。比较，就需要比较前面一个和后面一个。这样更加准确，只要二者都不相同，那么肯定就是它了(for 里面是 i+2 的操作)暴力肯定不是最优解，如果数组中有一万个变量呢，排序都是一个大问题。12345678910var singleNumber = function(nums) &#123;let len = nums.length; nums = nums.sort((x, y) =&gt; x - y); if (nums[0] != nums[1]) return nums[0]; if (nums[len - 1] != nums[len - 2]) return nums[len - 1]; for (let i = 2; i &lt; len - 2; i += 2) &#123; if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) return nums[i];&#125; &#125; 解法 2 去重法 利用 JS 的 Set 方法这个思路就很简单，如果不存在就往里面放该数值，如果再次出现就删除！有限制—重复的元素必须是出现二次，不能是奇数次(3 次的话，不存在添加，存在删除，不存在添加)就会有大问题。最后 Set 里面只会剩下一个值，那个就是没有重复的数值。说实话，Set 取值(不知道数值的前提)是真的麻烦。如果能像数组那样，按照索引就好了。这里只好借助里面自带的循环，把数值取出来。123456789101112131415161718var singleNumber = function(nums) &#123; let hasObj = new Set() for (item of nums) &#123; if (hasObj.has(item)) &#123; hasObj.delete(item) &#125; else &#123; hasObj.add(item) &#125; &#125; let a hasObj.forEach(function(item) &#123; a = item &#125;); return a&#125;;let nums = [1, 1, 2, 2, 3, 3, 4]let a = singleNumber(nums)console.log(a) 解法 3 求差法思路：先对数组排序，显而易见的，单独出现一次的数据必然是出现在数组下标为偶数的位置（下标从 0 开始），那么所有奇数下标的元素之和减去偶数下标的元素之和，就是需要求得的结果。12345678var singleNumber = function(nums) &#123; nums.sort() let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = i % 2 == 0 ? sum + nums[i] : sum - nums[i] &#125; return sum&#125;; 解法 4 异或法根据异或运算的特点，相同的数字经过异或运算后结果为 0，除单独出现一次的数字外，其他数字都是出现两次的，那么这些数字经过异或运算后结果一定是 0。而任何数字与 0 进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案。其实严格来讲，只有第四种方式是题目想要的解法，其他三种方法都是有瑕疵的。也只有最后一种，时间复杂度是 O(n)空间复杂度 O(1)的。其他的二种有排序，时间复杂度不小，还一样 Set 需要额外的空间。列子： 1, 4, 2, 3, 2, 4, 1 对他们进行异或123456789最开始0的二级制表示为0000 0000，1的二进制表示为0000 00010000 0000 ^ 0000 0001 = 0000 0001//0和[1]进行异或获得的二进制转换成十进制就是1咯，把得到的1继续异或下面的数组0000 0001 ^ 0000 0100 = 0000 0101//1和[4]进行异或得到十进制数字是5，十进制没什么用了，我就不写了，继续异或0000 0101 ^ 0000 0010 = 0000 0111//0000 0111 ^ 0000 0011 = 0000 0100//0000 0100 ^ 0000 0010 = 0000 0110//0000 0110 ^ 0000 0100 = 0000 0010//0000 0010 ^ 0000 0001 = 0000 0011//最后就得到3了--------------------- 12345678var singleNumber = function(nums) &#123; let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = sum ^ nums[i] &#125; return sum&#125;; 对于最后一种方法，建议大家再去了解一下 JS 那些位运算。虽然数学上可能用的多，JS 上并没有大幅文字来讲解，但不代表它不重要。既然出现，就一定有使用它们的机会。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现存在重复]]></title>
    <url>%2F2018%2F12%2F05%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 方法 1 排序后循环遍历先对数组进行排序，然后如果存在重复的数值，那么这几个数值一定是在一起的，也就是连续的，遍历的时候，只需要对该位置和该位置的后一个位置的数值进行比较就可以，两者相等，那么直接返回 true。遍历结束不存在，则返回 false12345678var containsDuplicate = function(nums) &#123; nums.sort() for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i + 1]) &#123; return true &#125; &#125; return false&#125;; 方法 2 哈希表哈希表特性我就不啰嗦，思路老套路：不存在就向表中存数据，存在返回值其实总结一些算法题：存在重复字眼的。都离不开哈希表(我说大多数啊 哈 毕竟我做的也不是很多啊。)考虑一下也无妨啊，搞不好一下子就出来了呢？123456789101112var containsDuplicate = function(nums) &#123; let hasObj = new Map() for (item of nums) &#123; if (hasObj.has(item)) &#123; return true &#125; else &#123; hasObj.set(item) &#125; &#125; return false&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
</search>
