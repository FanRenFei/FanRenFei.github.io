<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第二十一天]]></title>
    <url>%2F2019%2F05%2F07%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[今天我询问了导师一些东西,本来是想继续往下进行，看一看OM的代码，了解下平台业务的开发，随后他就问了我一些东西，问我,在开发的过程中遇到哪些不顺的地方没有，我说没有。 随后凯哥就陷入沉思，眉头紧皱。再次说,真的没有遇到?我还是说，能看懂，但是自己还是在先有的基础上复制粘贴的，也就是需求会写，但是让自己开发却是有难度的. 随后他就说，底层的东西你知道不，需求说实话，都能开发出来，但是你怎么才能写出一个好的代码这就很有难度了。 你想学node又想看om代码，你都有涉及，但是都不精通，社会上是最不缺你这样的人。 听完凯哥的话，我就陷入沉思中，自己太想当然了。没有深入底层去了解，只是会开发，这个对自己的发展也是不友好的，也为上次例会吹牛皮感到尴尬。于是，自己就重新的学习dva，自己动手开发一个小demo。 下面是我们要实现的功能当页面加载的时候显示一堆名字为汉字的数据 当自己点击添加数据时候就会发送请求，获取新的数据点击删除的时候，能将改行的数据给删除掉 创建一个dva项目1234567npm install dva-cli -gdva new dva-quickstartcd dva-quickstartyarn start或者npm start 使用antd1npm install antd babel-plugin-import --save 按需加载antd编辑 .webpackrc，使 babel-plugin-import 插件生效。12345&#123; &quot;extraBabelPlugins&quot;: [ [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: &quot;css&quot; ] ]&#125; 下面就是我们创建的项目的目录 第一步将 components，models，routes 里面原有的文件删除(当然你也可以不删除，不影响) 首先编写一个组件，显示表格在components里面创建一个文件ProductList 代码如下: 123456789101112131415161718192021222324252627282930313233343536import React from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import &#123; Table, Popconfirm, Button &#125; from &apos;antd&apos;;const ProductList = (&#123; handleDelete,getTableData,dataSource &#125;) =&gt; &#123; const columns = [&#123; title: &apos;Name&apos;, dataIndex: &apos;name&apos;, &#125;, &#123; title: &apos;Actions&apos;, render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title=&quot;Delete?&quot; onConfirm=&#123;() =&gt; handleDelete(record.id)&#125;&gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;]; return ( &lt;div&gt; &lt;Button onClick=&#123;getTableData&#125; type=&quot;primary&quot;&gt;添加数据&lt;/Button&gt; &lt;Table dataSource=&#123;dataSource&#125; columns=&#123;columns&#125; /&gt; &lt;/div&gt; );&#125;;ProductList.propTypes = &#123; handleDelete: PropTypes.func.isRequired, getTableData: PropTypes.func.isRequired, dataSource: PropTypes.array.isRequired,&#125;;export default ProductList; 代码中的handleDelete,getTableData,dataSource都是调用它的父组件传递的值 我们会在routes里面的文件看见 第二步 定义调用UI组件的父组件 核心组件 routes里面命名为Products1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;;import &#123; connect &#125; from &apos;dva&apos;;import ProductList from &apos;../components/ProductList&apos;;const Products = (&#123; dispatch, products &#125;) =&gt; &#123; let &#123; dataSource &#125;=products const filterProps=&#123; getTableData()&#123; dispatch(&#123; type: &apos;products/query&apos;, params: &#123;&#125; &#125;) &#125;, handleDelete(id) &#123; dispatch(&#123; type: &apos;products/delete&apos;, payload: id, &#125;); &#125;, dataSource &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList &#123;...filterProps&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 代码中的products 是从对应的models文件中获取的，dispatch里面的type:’products/query’,”products/delete”都是定义在models里面的方法 代码的最下方，connect将models的文件和components里的文件关联起来。 定义models文件命名为products 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import * as productsService from &apos;../services/products&apos;export default &#123; namespace: &apos;products&apos;, state: &#123; dataSource:[] &#125;, effects:&#123; *query(&#123;&#125;, &#123; call, put &#125;)&#123; const data=yield call(productsService.query) if(data.data.code===&apos;0&apos;&amp;&amp;data.data.result)&#123; let dataSource=data.data.result yield put(&#123; type:&apos;updataState&apos;, params:&#123; dataSource &#125; &#125;) &#125; &#125;, *query1(&#123;&#125;, &#123; call, put &#125;)&#123; const data=yield call(productsService.query1) if(data.data.code===&apos;0&apos;&amp;&amp;data.data.result)&#123; let dataSource=data.data.result yield put(&#123; type:&apos;updataState&apos;, params:&#123; dataSource &#125; &#125;) &#125; &#125; &#125;, subscriptions:&#123; setup(&#123; dispatch,history &#125;)&#123; history.listen((location)=&gt;&#123; if(location.pathname===&apos;/&apos;)&#123; dispatch(&#123; type:&apos;query1&apos; &#125;) &#125; &#125;) &#125; &#125;, reducers: &#123; &apos;delete&apos;(state, &#123; payload: id &#125;) &#123; state.dataSource=state.dataSource.filter(item=&gt;item.id!==id); return &#123;...state&#125; &#125;, updataState(state,&#123;params&#125;)&#123; return &#123;...state,...params&#125; &#125; &#125;, &#125; 最后一步定义services文件1234567891011121314151617import request from &apos;../utils/request&apos;;export function query() &#123; let url=&quot;https://easy-mock.com/mock/5cd14003bbe6b75014dac66e/productions/table&quot;; let options=&#123; method:&quot;GET&quot; &#125; return request(url,options);&#125;export function query1() &#123; let url=&quot;https://easy-mock.com/mock/5cd14003bbe6b75014dac66e/productions/host&quot;; let options=&#123; method:&quot;GET&quot; &#125; return request(url,options);&#125; 这里面都是发送的请求的，路径都是我在Easy Mock 直接创建的数据接口。你们也可以自己去创建自己的接口。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十一天]]></title>
    <url>%2F2019%2F05%2F06%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[下面的代码是在函数中的12345678910111213141516171819if (flag) &#123; console.log(&apos;1&apos;)&#125; else &#123; if (intervalTime &lt;= 0) &#123; if (days &gt; 7) &#123; console.log(&apos;2&apos;); &#125; else &#123; axios.get(&apos;url&apos; + page + derivedParams).then(res =&gt; &#123; if (res &amp;&amp; res.status === 200 &amp;&amp; res.data.code === 0) &#123; console.log(&apos;3&apos;) &#125; else &#123; console.log(&apos;4&apos;) &#125; &#125;) &#125; &#125; else &#123; console.log(&apos;5&apos;) &#125;&#125; 上面的到代码怎么样? 不想看吧，这就是我写的代码，写的时候就感觉这个非常不舒服，最后果然被凯哥点到，让我以后遇到这种情况尽量使用return来优化 使用return 优化后的结果(把else也要去掉)1234567891011121314151617if (flag) &#123; console.log(&apos;1&apos;) return&#125; if (intervalTime &lt;= 0) &#123; if (days &gt; 7) &#123; console.log(&apos;2&apos;) return; &#125; if (res &amp;&amp; res.status === 200 &amp;&amp; res.data.code === 0) &#123; console.log(&apos;3&apos;) return &#125; console.log(&apos;4&apos;) return&#125; console.log(&apos;5&apos;) 合并同类项12345678910111213141516 if (!flag) &#123; if (intervalTime &lt;= 0) &#123; if (days &lt;= 7) &#123; if (res &amp;&amp; res.status === 200 &amp;&amp; res.data.code === 0) &#123; console.log(&apos;3&apos;) return &#125; console.log(&apos;4&apos;) return &#125; console.log(&apos;2&apos;) return &#125; console.log(&apos;5&apos;)&#125; console.log(&apos;1&apos;) if条件反转1234567891011121314151617if(flag)&#123; console.log(&apos;1&apos;) return&#125;if(intervalTime&gt;0)&#123; console.log(&apos;5&apos;) return&#125;if(days&gt;7)&#123; console.log(&apos;2&apos;) return&#125;if(res &amp;&amp; res.status === 200 &amp;&amp; res.data.code === 0) &#123; console.log(&apos;3&apos;) return &#125;console.log(&apos;4&apos;) 这是最终简化的结果. 平时遇到的if简化12345if(a为真)&#123; a=a&#125;else&#123; a=b&#125; 简化后 a=a||b 12345if(a==b)&#123; a=c&#125;else&#123; a=d&#125; 简化后 a=(a==b)?c:d 下面这种场景场景一12345678910111213141516function func(fruit)&#123; let shuiguo=&quot;&quot; if(fruit===0)&#123; shuiguo=&apos;苹果&apos; &#125;else if(fruit===1)&#123; shuiguo=&apos;梨子&apos; &#125;else if(fruit===2)&#123; shuiguo=&apos;桔子&apos; &#125;else if(fruit===3)&#123; shuiguo=&apos;柠檬&apos; &#125;else&#123; shuiguo=&apos;芒果&apos; &#125; console.log(shuiguo)&#125;func(1)//梨子 简化后的结果 123456function func(fruit)&#123; var _f = [&apos;苹果&apos;,&apos;梨子&apos;,&apos;桔子&apos;,&apos;柠檬&apos;,&apos;芒果&apos;]; let shuiguo = _f[fruit]; console.log(shuiguo)&#125;func(1)//梨子 场景二123456789101112function func(key)&#123; let val=&quot;&quot; if (key == &quot;Apple&quot;) &#123; val = &quot;Jobs&quot;; &#125; else if (key == &quot;microsoft&quot;)&#123; val = &quot;Gates&quot;; &#125; else if (key == &quot;Google&quot;)&#123; val = &quot;Larry&quot;; &#125; console.log(val)&#125;func(&apos;Apple&apos;)//Jobs 简化后的结果 12345678910function func(key)&#123; let obj=&#123; &quot;Apple&quot;:&quot;Jobs&quot;, &quot;microsoft&quot;:&quot;Gates&quot;, &quot;Google&quot;:&quot;Larry&quot; &#125; let val=obj[key] console.log(val)&#125;func(&apos;Apple&apos;)//Jobs]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十天]]></title>
    <url>%2F2019%2F05%2F05%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[说好今天早上六点半起床的，小爱同学居然没有提醒我。 质问她，她却说我手机上有闹铃软件阻止了它。最终在八点左右的时间起床了。 好久没有起这么久，早上起来的时候，自己还是很懵的，坐在椅子上也不知道自己要做啥子。磨磨唧唧看了一些英语单词，随后没过多久就该去上班了。 坐到工位上，好困啊~ 今天看代码,发现一个知识点就是 Object.keys 源代码123for(let k of Object.keys(obj1))&#123;.......&#125; Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组,数组中属性名的排列顺序和使用for…in循环遍历该对象时的顺序一致 123456let obj1=&#123; age:1, name:&apos;fishfan&apos;, address:&apos;北京海淀领航&apos;&#125;console.log(Object.keys(obj1))//[ &apos;age&apos;, &apos;name&apos;, &apos;address&apos; ] 上面的列子说明，遍历对象属性，最终返回的一个属性集合的数组. 12let arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]console.log(Object.keys(arr))//[ &apos;0&apos;, &apos;1&apos;, &apos;2&apos; ] 遍历数组的时候，会返回该数组的索引值，但是所有的元素都是字符串. 1234567let obj1 = &#123; age: 1, name: &apos;fishfan&apos;, address: &apos;北京海淀领航&apos;&#125;obj1.__proto__.sex=&quot;男&quot;console.log(Object.keys(obj1))//[ &apos;age&apos;, &apos;name&apos;, &apos;address&apos; ] 原型上的属性是不会被遍历的 总结Object.keys()返回一个所有元素为字符串的数组，其元素来自于给定的object上面可枚举的属性，这些属性的顺序与手动遍历该对象的属性时的一致]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十九天]]></title>
    <url>%2F2019%2F05%2F04%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[早上6点多醒的，醒后的第一件事就是提醒一个人起床学习。 本来打算今天学习的，但是自己仍然是浑浑噩噩的，继续王者，吃鸡，刷抖音。 中午感觉自己必须吃饭，出去找了一家店吃，没胃口，难吃，辣。 肠炎就犯了，一个劲的想去厕所，厕所，床上，厕所，床上！！！！ 重复，无奈之下只要在淘宝下单买肠炎宁片。 深夜的时候，和妈妈聊起自己的这件事情。 妈妈很生气，她以为我找到好工作就抛弃了女友，我肯定不是这样的，妈妈还是很不希望我们分手的，因为认识一个人真的不容易，你的人生有很多人，了解你的除了你的父母，就是你的另一半。我和她终于能够互相认识对方，但是最终却分开， 然后就成为最熟悉的陌生人。这是一件很可惜的事情也是一件很痛苦的事情。妈妈还是希望我能够去找女孩聊聊天，果断拒绝了，分手是我提出来的，然后我又去主动找她聊天，这叫啥事啊。分手的时候，总要有一个人做恶人的。 以前你会叫我老公，会给我视频让我看看， 后来你再也不想喊我老公，再也不会和我视频。 以前你总是能在我不找你的时候，主动找我聊天 后来你只有等待，等待我去找你 累了， 年纪轻轻碰什么不好，为什么非要碰爱情？]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十八天]]></title>
    <url>%2F2019%2F05%2F03%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[早上醒来都不知道要做什么，只知道自己很痛苦，很痛苦。 还是在想念她，一天都在床上，椅子上度过，扣手机，还是扣手机。仿佛手机已经成为我的一切，打游戏，打完玩游戏刷抖音，压根不知道自己想要做什么?说好的学习呢？ 王者-吃鸡-抖音-王者-吃鸡-抖音 重复的东西，有时候看看天花板，自己还是陷入的沉思. 一天没有吃饭根本察觉不到饿的滋味。下午的时候，点了一只炸鸡。 就这样自己的一天假期就过去了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十七天]]></title>
    <url>%2F2019%2F05%2F02%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[下午五点左右张越就带走了，虽然她的票是明天的，她也在测试我，如果提前一天走，我会不会挽留她，最终我还是没有挽留，因为我知道就在今天，我和她终究会有一个了结。 本来打算下午带她去王府井然后在和她一起去天坛，最终天坛还是没有去成，原因挺多的： 她是想吃北京烤鸭，我们先到了一家店，然后坐下去，准备去点菜，她看到菜单上的菜都很贵，很舍不得，我虽然说没事，但是她还是不想吃，我心里挺不是滋味的。随后只能带她去吃一些小吃 王府井的小吃很坑！！！！全都是奸商X100她只好买袋子装的北京烤鸭，我呢顺手就在店里面买了一些糕点，这个糕点是真的难吃，真的不知道皇帝当初是怎么喜欢吃的这些玩意的，虽然忍着脚痛，陪她一起去寻找那个邮政站点，随后，她还是想去吃那个北京烤鸭，于是再次来到那家店，点了一份后，她就一直追问，我今天要说什么？ 最终我还是说了出来，你不是我喜欢的类型。。。 说出那句话的时候，我的心都碎了，我纠结了很长时间。 我真的很对不起她，每天我的脑子都是学习，真的不知道为什么，很想谈恋爱，但是却不想花费时间在感情上。渐渐的，在恋爱上花费的时间越来越多，自己越来越不想谈。每天不能见面，只能通过手机聊天来维持感情的，真的好痛苦。 她沉默了好久，然后拿起东西就走，我要跟着她，这应该是我们之间最后的一段时光了，地铁上看到她眼睛上的泪光，自己愈加难受,超级痛苦。自从认识她，只有在高一的时候讲过她手被订书机钉子钉了，才哭过，这么久了，第二天见她苦。她是一个比我坚强的人，我虽然是一个男孩，但是当自己想哭的时候，自己还是会大声的哭出来。 后来在一家店里点了饮料，我也说了很多，我知道她也不想听下去了，在她眼里我就是个垃圾，说的话都是屁。 回到屋里，看到手机里给她拍的照片，忍不住的哭了出来，很大声的那种，真的憋不住，这种痛苦的感觉，我已经体验到了两次，都是和她。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六天]]></title>
    <url>%2F2019%2F05%2F01%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[昨天媳妇张越来了，昨天下午特意很早就走了，大约7点的时候。 给她说的是知春路，这个傻孩子跑到了知春里，害我多绕了一圈。走的时候特意拿来公司的香蕉送给这个傻子。 见到的她的时候她手里拿着地铁口的煎饼果子（那种很难吃的），边吃边说，北京的煎饼果子真难吃。哈哈，看来她还是饿的轻，用我妈妈的话说就是饿的很的时候，屎都是香的。给了她一个香蕉让她先填填肚子。 随后带她去了前几天闯爷带我们去吃饭的地方，点了一份鱼。(鱼你在一起) 本来是想夜里看看复仇者联盟4，然后就回家睡觉，哪想，她想去天安门看升国旗。这注定要熬夜，我其实是不想的，因为熬夜的滋味是真的很难受，我是真的不想体验熬夜的滋味。但是她想，就陪她一起吧。随后我们定了王府井横店电影院的两张门票，凌晨0点到三点的。原来复仇者联盟是真的三个小时啊。第一次看这么长的电影。 电影确实很好看，但是黑寡妇和钢铁侠死了，黑寡妇是活活的摔死的，托尼是被原石的伽马射线给辐射死的，钢铁侠真的很帅，最后一截，一个响指把灭霸给消灭了。 三点多从电影院出来，(吐槽下，这个电影院，当北京百货大楼关闭的时候是真的不好找。)就开始向天安门出发，路途中遇到很多一起去天安门的人，本以为三点多去应该人不多，没想到居然这么多人 ，到地方的我们惊呆了，这辈子还没有见过这么多人呢。哎 看来只能看见国旗升起是看不到仪仗队了。三点多到达地方的，最后等到5点多，国旗升起的那一刻，整个天安门真的很静，静到仿佛掉一根针就能够听到。 随后就随着人流走了，这时候北京地铁东站和西站都关闭了，只能去王府井。 坐在地铁上那个困啊，她靠在我的肩膀上睡觉，我迷迷糊糊，生怕坐错站。回来就埋头大睡。 下午去了颐和园，人多，多的人。排了很久的队伍才买到票 进去的时候，人很挤，和当初的趵突泉有一拼，转了一下午，随后才发现很多好玩的地方都没有去。今天一天跑啦三万多步]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五天]]></title>
    <url>%2F2019%2F04%2F30%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[上一周提交代码的时候，导师凯哥就给我提出代码规范的问题，我这里总结一下 for in 时，需要添加Object.prototype.hasOwnProperty判断原始代码12345for(let k in params)&#123; if(params[k])&#123; ...... &#125;&#125; 上面是我写出的代码，其实是有问题的，for in 遍历的是params里面所有的属性，包括原型上的 123456789101112let params=&#123; age:1, name:&apos;fishfan&apos;, add:function()&#123; console.log(11) &#125;&#125;params.__proto__.address=&quot;xxxxxx&quot;for(let k in params)&#123;console.log(k) //age name add address&#125; 如果我们加上hasOwnProperty判断 12345678910111213let params=&#123; age:1, name:&apos;fishfan&apos;, add:function()&#123; console.log(11) &#125;&#125;params.__proto__.address=&quot;xxxxxx&quot;for(let k in params)&#123; if(params.hasOwnProperty(k))&#123;console.log(k)&#125; //age name add &#125; 很明显 ，params原型上面的address属性并没有被打印出来。 采用===时，最好把变量显示转换类型，增强代码容错性源代码 1if(res.state===200&amp;&amp;res.data.code===0)&#123;&#125; 这里主要考虑到res.state可能是’200’,res.data.code可能是’0’，如果我们采用的是===的话，那么这种情况下就会报错，但是如果使用= =自然不会出现这种情况，但是在ESlint下= =是不能使用的。只能使用= = =。 这里我们就需要进行了类型转换 1if(Number(res.state)===200&amp;&amp;Number(res.data.code)===0)&#123;&#125; 这样处理，无论后端传给我们是字符串’200’还是字符串’0’，我们都能够正常处理]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四天]]></title>
    <url>%2F2019%2F04%2F29%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[我从0到完全接收dva项目的时间是短短10天时间，了解项目代码的框架结构是接手项目最关键的一步。 dva项目的结构这里主要讲解src下的文件和其他重要文件 12345678910111213├── /mock/ # 数据mock的接口文件├── /src/ # 项目源码目录│ ├── /components/ # 项目组件│ ├── /routes/ # 路由组件（页面维度）│ ├── /models/ # 数据模型│ ├── /services/ # 数据接口│ ├── /utils/ # 工具函数│ ├── route.js # 路由配置│ ├── index.js # 入口文件│ ├── index.less │ └── index.html ├── package.json # 定义依赖的pkg文件└── proxy.config.js # 数据mock配置文件 components文件这个文件主要就是放一些公用的组件，这里就是写组件，不触及数据的逻辑处理。因为它是公用的组件库，肯定要满足各个调用它的文件。 通常为自定义的公用组件，特用的组件需和引用它的父组件放在同一目录。 routes文件组件目录，这个文件我们项目的核心 models文件数据模型文件，这里面管理你所有的全局数据状态，用于更新数据，更新组件状态 12345namespace:&quot;string&quot; 命名空间，在routes里面的文件调用model的方法时需要用到state:&#123;&#125; 初始数据仓库reducers:&#123;&#125; 数据操作，定义改变state的方法，这是一个纯函数(输入相同的值出来的一定是同样的值)effects:&#123;&#125;动作操作,用来操作reducers，返回新数据更新视图subscriptions:&#123;&#125; 订阅，监听一个路径，发起请求得到数据 services文件这个文件就是存放向后端发送请求的方法axios，ajax等 文件的关联route文件直接调用component组件，使用dispatch方法调用model内的方法，route里面的数据是从model里面的state获取的，model获取数据通过调用services里面的异步函数获取的]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三天]]></title>
    <url>%2F2019%2F04%2F28%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[五一假期很真实，两个周日换一下，然后挤出来一个四天假。对于这样的zhengce我只能说牛逼。 今天是补周四的时间，今天也是我最后在酒店留宿的一天，早上就去把房间给退了，走的时候顺手把房间送的水带走，那玩意四块钱呢。 今天差不多就把代码给看完了。也懂个大概，那么继续补充自己的Pormise吧 这里我们先实现一个Promise对象实现的Ajax操作的例子(来自阮一峰ES6入门)12345678910111213141516171819202122232425262728const getJSON=function(url)&#123; const promise=new Promise((resolve,reject)=&gt;&#123; const handler=function()&#123; if(this.readyState!==4)&#123; return; &#125; if(this.status===200)&#123; resolve(this.response); &#125;else&#123; reject(new Error(this.statusText)); &#125; &#125;; const client=new XMLHttpRequest(); client.open(&quot;GET&quot;,url); client.onreadystatechange=handler; client.responseType=&quot;json&quot;; client.setRequestHeader(&apos;Accept&apos;,&quot;application/json&quot;); client.send(); &#125;); return promise&#125;;getJSON(&quot;/posts.json&quot;).then(json=&gt;&#123; console.log(&apos;Contents:&apos;+json)&#125;,error=&gt;&#123; console.error(&apos;出错了&apos;,error)&#125;) Promise.prototype.then()then方法返回的是一个新的Promise实例(不是原来的Promise实例)。因此可以采用链式写法，即then后面在调用另一个then方法 1promise.then(()=&gt;&#123;return &#125;).then(()=&gt;&#123;&#125;) 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数. Promise.prototype.catch()Promise.prototype.catch方法是.then(null,rejection)或.then(undefined,rejection)的别名，用于指定发生错误时的回调函数。 12345getJSON(&apos;/error.json&apos;).then(post=&gt;&#123;&#125;).catch(error=&gt;&#123; console.log(&apos;错误&apos;,error)&#125;) 上面的代码中,getJSON方法返回一个Promise对象，如果该对象状态变成resolved,则会调用then方法指定的回调函数;如果异步操作抛出错误，状态就会变成rejected,就会调用catch方法指定的回调函数,处理这个错误，另外，then方法指定的回调函数,如果运行错误，也会被catch方法捕获。 12345promise.then((val)=&gt;console.log(&apos;fulfilled:&apos;,val)).catch((err)=&gt;console.log(&apos;rejected&apos;,err));//等同于promise.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val)) .then(null, (err) =&gt; console.log(&apos;rejected&apos;, err)) 一般来说，不要在then方法里面定义Reject状态的回调函数(即then的第二个参数)，总是使用catch方法 12345678910111213//badPromise.then(data=&gt;&#123; //success&#125;,err=&gt;&#123; //error&#125;);//goodPromise.then(data=&gt;&#123; //success&#125;).catch(err=&gt;&#123; //error&#125;) 上面的代码中，第二种写法要好于第一种写法。因为第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法(try/catch),因此，建议总使用catch方法，而不是使用then方法的第二个参数。 1234567891011const someAsyncThing=function()&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(x+2) &#125;);&#125;;someAsyncThing().then(()=&gt;&#123; console.log(&apos;everything s&apos;)&#125;)setTimeout(() =&gt; &#123; console.log(123)&#125;, 2000); 按照从上到下的顺序，someAsyncThing函数产生的Promise对象，内部是由语法错误的，虽然会报错，但是2s后仍然后打印123，这就是说，Promise内部的错误不会影响到Promise外部的代码，通俗的说””Promise会吃掉错误”; Promise.prototype.finally()finally方法用于指定不管Promise对象最后状态如果，都会执行的操作 1234promise.then(resulu=&gt;&#123;...&#125;).catch(error=&gt;&#123;....&#125;).finally(()=&gt;&#123;....&#125;) 上面代码不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 Promise.all()Promise.all方法将用于将多个Promise实例，包装成一个新的Promise实例。 Promise.all(iterable)参数是一个迭代器! 1const p = Promise.all([p1,p2,p3]) 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 123456789let promise1=Promise.resolve(2);let promise2=42;let promise3=new Promise((resolve,reject)=&gt;&#123; setTimeout( resolve, 1000,&apos;foo&apos;);&#125;)Promise.all([promise1,promise2,promise3]).then(values=&gt;&#123; console.log(values)//[ 2, 42, &apos;foo&apos; ]&#125;) 12345678910111213141516171819202122232425262728293031let state=1function step1(resolve,reject)&#123; if(state===1)&#123; resolve(&apos;step1 resolve&apos;) &#125;else&#123; reject(&apos;step1 reject&apos;) &#125;&#125;function step2(resolve, reject) &#123; if (state === 1) &#123; resolve(&apos;step2 resolve&apos;) &#125; else &#123; reject(&apos;step2 reject&apos;) &#125;&#125;function step3(resolve, reject) &#123; if (state === 1) &#123; resolve(&apos;step3 resolve&apos;) &#125; else &#123; reject(&apos;step3 reject&apos;) &#125;&#125;let p1=new Promise(step1)let p2=new Promise(step2)let p3=new Promise(step3)Promise.all([p1,p2,p3]).then(()=&gt;&#123; console.log(&apos;都是成功&apos;)&#125;).catch(()=&gt;&#123; console.log(&apos;至少一个失败&apos;)&#125;) //都是成功 12345678910111213141516171819202122232425262728293031let state=1function step1(resolve,reject)&#123; if(state===1)&#123; resolve(&apos;step1 resolve&apos;) &#125;else&#123; reject(&apos;step1 reject&apos;) &#125;&#125;function step2(resolve, reject) &#123; if (state === 1) &#123; resolve(&apos;step2 resolve&apos;) &#125; else &#123; reject(&apos;step2 reject&apos;) &#125;&#125;function step3(resolve, reject) &#123; if (state === 3) &#123; resolve(&apos;step3 resolve&apos;) &#125; else &#123; reject(&apos;step3 reject&apos;) &#125;&#125;let p1=new Promise(step1)let p2=new Promise(step2)let p3=new Promise(step3)Promise.all([p1,p2,p3]).then(()=&gt;&#123; console.log(&apos;都是成功&apos;)&#125;).catch(()=&gt;&#123; console.log(&apos;至少一个失败&apos;)&#125;)//至少一个失败 Promise.race()Promise.race方法同样是将多个Promise实例包装成一个新的Promise实例1const p = Promise.all([p1,p2,p3]) 上面的代码中，只要p1,p2,p3之中有一个实例率先改变状态，p的状态就会跟着改变，那个率先改变的Promise实例的返回值就会传递给p的回调函数。 12345678910111213141516171819202122232425262728293031let state=1function step1(resolve,reject)&#123; if(state===2)&#123; resolve(&apos;step1 resolve&apos;) &#125;else&#123; reject(&apos;step1 reject&apos;) &#125;&#125;function step2(resolve, reject) &#123; if (state === 1) &#123; resolve(&apos;step2 resolve&apos;) &#125; else &#123; reject(&apos;step2 reject&apos;) &#125;&#125;function step3(resolve, reject) &#123; if (state === 3) &#123; resolve(&apos;step3 resolve&apos;) &#125; else &#123; reject(&apos;step3 reject&apos;) &#125;&#125;let p1=new Promise(step1)let p2=new Promise(step2)let p3=new Promise(step3)Promise.race([p1,p2,p3]).then(()=&gt;&#123; console.log(&apos;率先完成的是成功resolve&apos;)&#125;).catch( ()=&gt;&#123;console.log(&apos;率先完成的是失败reject&apos;)&#125;)//率先完成的是失败reject 因为按照顺序step1先执行，那么他的状态走向也就决定了最终的走向。 12345678910111213141516171819202122232425262728293031let state=1function step1(resolve,reject)&#123; if(state===1)&#123; resolve(&apos;step1 resolve&apos;) &#125;else&#123; reject(&apos;step1 reject&apos;) &#125;&#125;function step2(resolve, reject) &#123; if (state === 1) &#123; resolve(&apos;step2 resolve&apos;) &#125; else &#123; reject(&apos;step2 reject&apos;) &#125;&#125;function step3(resolve, reject) &#123; if (state === 3) &#123; resolve(&apos;step3 resolve&apos;) &#125; else &#123; reject(&apos;step3 reject&apos;) &#125;&#125;let p1=new Promise(step1)let p2=new Promise(step2)let p3=new Promise(step3)Promise.race([p1,p2,p3]).then(()=&gt;&#123; console.log(&apos;率先完成的是成功resolve&apos;)&#125;).catch( ()=&gt;&#123;console.log(&apos;率先完成的是失败reject&apos;)&#125;)//率先完成的是成功resolve 应用Generator函数与Promise的结合使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve(&apos;foo&apos;); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二天]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[早上在宾馆的床上躺了很久,主要就是在打王者荣耀和刺激战场。 沿着窗帘漏出的缝隙来看，外面是个阴天。打算下午去出租屋收拾房子。上午的主要任务就是打游戏。看了一会抖音找到一个例子，自己也跟风拍了一部，居然有1.4W的浏览量。 中午是点的外卖，下午准备走的时候，才发现外面居然下起了大雨，不得已叫个滴滴。 进入出租屋，就发现自己的东西全在门口，这个不错，我还以为房东把我的东西都放在他的房间，那么他出去我就收拾不了屋子了。 忙了一下午还购置了一些东西，终于把房间给收拾干净了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一天]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[今天是团建，上午干了什么确实已经忘了。 中午组里的人一起出去吃了吃饭，下午就去玩了。 下午两点多出发的。我和曹指导，岳檑，程婷婷一起打了一个车。目的地奥林匹克森林公园。 奥森对面就是鸟巢和水立方，路途经过，但是并未止步进入。和组里其他人约定的地点是在奥森里面。沿途的花花草草，我以为是假的呢，说实话从来没有见到这么鲜艳和密集的花朵。 道路的右方是奥运塔，起初还不知道名字，问别人，别人说大钉子。。。 大家聚集到一起后，后端组是在一起玩狼人杀。我和岳檑， 熊老师，冰爷，婷婷一起玩UNO。 这是一个纸牌的桌游，以前并没有玩过，玩个好几句才知道规则，真的很好玩。以前觉得狼人杀很好玩，但是狼人杀费时间，很久才能轮到自己发言，但是这个UNO纸牌游戏很好玩，每次冰爷和熊老师让我赶紧出牌的时候，我总是会来一张+4. 夜里去的是捞捞福火锅，闯爷说这个比海底捞还高级。去啦以后，每人一个小锅。领导说，好不容来来吃一顿，吃的太普通不好，于是点的全都是海鲜，说实话第一次吃这么多海鲜。感觉自己不是吃这种高级食品的命，总感觉这些东西不是特别好吃。 夜里观赏奥运塔美景，下图]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十天]]></title>
    <url>%2F2019%2F04%2F25%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%8D%81%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[无状态函数 stateless function这种函数被dva的作者热烈推荐，意思就像名字一样，函数内部是没有state的。在写dva的架构中，我们基本上不需要用到state的。 如果我们想在页面中显示””hello world”12345678function Welcome(props)&#123; return &lt;h1&gt;hello &#123;props.name&#125;&lt;/h1&gt;&#125;const element = &lt;Welcome name=&quot;world&quot; /&gt;ReactDom.render(element,document.getElementById(&apos;root&apos;)) 当react看到表示用户自定义组件的元素的时候，它会将JSX属性作为单个对象传递给此组件，我们称这个对象为”道具”; 拿上面这个例子来看 1name=&quot;world&quot; 会被看做&#123;name:world&#125; 然后成为函数的中的参数props React会调用Welcome组件{name:’world’}作为道具. Promise什么是Promise Promise是对异步编程的一种抽象，它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常 阮一峰的ES6入门是这样说的 12所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，从语法上说，Promise是一个对象，从它可以获取异步操作的消息，Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象的特点(摘录于阮一峰的ES入门)对象的状态不受外界影响Promise对象代表一个异步操作，有三种状态:pending(进行中),fulfilled(已成功和reject(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是Promise这个对象的由来，它的英文意思就是承诺，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果Promise对象的状态改变，只有两种情况:从pending变成fulfilled和从pending变成rejected。只要这两种情况发生，状态就会凝固，不会再变了，会一直保持这个结果,这时就成为resolved(已定型)。如果改变已经发生，你在对Promise对象添加回调函数，也会立即得到这个结果.这与事件(Event)完全不同，事件的特地是，如果你错过了它，再去监听，是得不到结果的。 基本用法1234567const promise =new Promise((resolve,reject)=&gt;&#123; if(true)&#123; resolve() &#125;else&#123; reject(error) &#125;&#125;) resolve函数是将Promise对象的状态从pending变成fulfilled reject函数是将Promise对象的状态从pending变成rejected thenthen可以接受两个回调函数，第一个函数是在对象变成resolved时调用,第二个回调函数是对象变成rejected时调用，第二个函数(状态变为rejected时触发的函数)是可选的，下面例子 1234567891011121314151617181920212223function timeout(ms)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(reject,ms) &#125;)&#125;timeout(1000).then((value=&gt;&#123; console.log(&apos;resolve&apos;)&#125;),()=&gt;&#123; console.log(&apos;reject&apos;)&#125;)//rejectfunction timeout(ms)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms) &#125;)&#125;timeout(1000).then((value=&gt;&#123; console.log(&apos;resolve&apos;)&#125;),()=&gt;&#123; console.log(&apos;reject&apos;)&#125;)//resolve 注意resolve函数的参数除了正常值之外，还可能是另一个Promise实例，比如 123456const p1=new Promise((resolve,reject)=&gt;&#123;&#125;);const p2=new Promise((resolve,reject)=&gt;&#123; resolve(p1)&#125;) 上面的代码中，p1和p2都是Prmoise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作. 这时候，p1的状态会传递给p2，也就是说p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变,如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立即执行. resolve或reject并不会终结Promise的参数函数执行. 123456new Promise((resolve,reject)=&gt;&#123; resolve(1); console.log(2);&#125;).then(r=&gt;&#123; console.log(r,&apos;r&apos;)&#125;)// 2 1 &apos;r&apos; resovle的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务. 一般来说，调用resolve或reject以后，Promise的使命就完成了，后续操作应该放在then方法里面，而不应该直接写在resolve或reject的后面。所以最好在它们前面加上return语句，这样就不会有意外. 12345new Promise((resolve,reject)=&gt;&#123; return resolve(1); //后面的语句不会执行 console.log(2);&#125;)]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九天]]></title>
    <url>%2F2019%2F04%2F24%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%B9%9D%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[今天完成了之前那个特别简单的一个需求。随后代码提交了以后，凯哥看了以后提出了不少的问题。其中就讲到了发送ajax请求的时候使用异步请求。异步编程这个我也就在准备面试的时候了解过，项目中还没有用到。今天就重学下异步编程 Generator/yieldgenerator是dva中所采用的异步编程编程,在dva项目中的model文件中 123effects:&#123; *func()&#123;&#125;&#125; 函数名字前面加*，就表示这是一个generator异步编程函数，我们首先先看下generator的内部运行机制 123456789101112function* generatorNaturalNumber()&#123; console.log(&apos;function start&apos;) let i=0; while(i&lt;=5)&#123; console.log(&apos;yield start&apos;); yield i; console.log(&apos;yield end&apos;); i++; &#125; console.log(&apos;function end&apos;)&#125;let result=generatorNaturalNumber(); 当我们运行完上面的代码之后你会发现，什么都没有打印出来。当我们打印result时，出现的结果 1cosole.log(result)//Object [Generator] &#123;&#125; 事实上result就是一个生成器，所以调用生成器函数必定会返回一个生成器，同时不会执行内部的任何代码。 1let result=generatorNaturalNumber(); generatorNaturalNumber()调用该函数后返回的是一个生成器，然后生成器赋值给了result。 那么问题来了，生成器函数内的代码是啥时候执行？怎么才能执行？ 答案是调用生成器的next方法 123result.next()打印结果:function start yield start 再次执行result.next()123result.next()打印结果:yield end yield start 接着调用result.next() 123result.next()打印结果:yield end yield start 下面就不打印了 直接上图吧,看图更清晰 输出的结果和普通函数是一样的，只要done是false，就一直调用next() 很直观的可以看出调用next返回一个object，包含两个属性done和value，符合迭代器协议。 同时注意调用第一次next打印了’’function start’ 和 ‘yield start’ 后续调用打印了 ‘yield end ‘和 yield end’，最后一次调用next打印的是’’yield end’和’’function end’.最后一次done是为false的。 所以运行原理是这样的： 调用第一次next，从函数开头开始运行,直到遇到第一个yield，如果没有yield，就直接运行完整个函数。 遇到yield则暂停运行，将yield后面的表达式求值之后返回,当作调用next返回的value属性值。 调用第二次next,从上一次暂停处继续运行，直到遇到了下一个yield,又暂停，依次循环，知道运行到return或者函数结尾，最后退出函数 下面是遇到return的例子 1234567891011function *foo(x)&#123; let y=2*(yield(x+1)) console.log(&apos;y的值&apos;,y) let z=yield(y/3) console.log(&apos;z的值&apos;,z) return (x+y+z)&#125;let it=foo(5)console.log(it.next()) //&#123; value: 6, done: false &#125;console.log(it.next(12))//y的值 24 &#123; value :8, done: false &#125;console.log(it.next(13)) //z的值 13 &#123; value: 42, done: true &#125; 当第一次执行next时,传入的参数会被忽略(你可以在第一个next里面添加参数，但是你会发现并没有什么用)，并且函数暂停在yield(x+1)处，所以返回5+1=6(value的值) 当第二次执行的时,传入的参数等于上一个yield的值，传入的参数12就会被当做上一个yield表达式的返回值，如果你不传参，yield永远返回undefined。所以此时y=2*12,所以第二个yield等于24/3=8 当执行第三次next时，传入的参数会传递给z，所以z=13,x=5,y=24相加等于42 next上面其实已经结果过next这个函数，这里做下总结: next也可以接受一个任意参数，该参数将作为上一个yield的返回值。yield也有返回值? yield作为一个关键字，也有返回值，其返回值就是下一次调用next传入的参数。(神奇吧，自己先执行，但会返回值居然是下一次调用传入的)。 yield和yield*看下面的代码使用的是yield12345678910111213function* outer()&#123; yield &apos;begin&apos;; yield inner(); yield &apos;end&apos;;&#125;function* inner()&#123; yield &apos;inner1&apos; yield &apos;inner2&apos;&#125;let it=outer()console.log(it.next()) //&#123; value: &apos;begin&apos;, done: false &#125;console.log(it.next()) //&#123; value: Object [Generator] &#123;&#125;, done: false &#125;console.log(it.next()) //&#123; value: &apos;end&apos;, done: false &#125; 如果我们使用yield* 1234567891011121314function* outer()&#123; yield &apos;begin&apos;; yield* inner(); yield &apos;end&apos;;&#125;function* inner()&#123; yield &apos;inner1&apos; yield &apos;inner2&apos;&#125;let it=outer()console.log(it.next()) //&#123; value: &apos;begin&apos;, done: false &#125;console.log(it.next()) //&#123; value: &apos;inner1&apos;, done: false &#125;console.log(it.next()) //&#123; value: &apos;inner2&apos;, done: false &#125;console.log(it.next()) //&#123; value: &apos;end&apos;, done: false &#125; 两者对比一下就会知道yield和yield* 两者的区别 yield后面可以跟任何表达式，表达式的值将作为调用next返回值的value属性值 yield* 后面接受的就是一个迭代器。 yield* 如果后面是一个迭代器那么就会将和这个迭代器迭代完毕以后才会继续进行下面的操作 yield* 的功能是将迭代控制权交给后面的那个迭代器，达到递归迭代的目的，就好比将inner的代码直接写在outer里面一样 yield* 本身这个表达式的值就是迭代器迭代完成时(done:true)的返回值 调用generator function会返回一个generator object，这个对象本身也是一种iterable object，所以，我们可以使用yield* generator_function() 这种写法 是不是感觉好绕啊。在实际的使用过程中，yield* 一般用来在一个generator函数里‘执行’另一个generator函数,并可以取得返回值。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八天]]></title>
    <url>%2F2019%2F04%2F23%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%85%AB%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[dva的学习介绍dva首先是一个基于redux和redux-saga的数据流方案，然后为了简化开发体验，dva还额外内置了react-router和fetch，所以也可以理解为一个轻量级的应用框架 背景redux学习复杂度很高，内容蛮复杂的，dva其实就是将redux封装起来，对外只有简单的6个api，上手或者操作使用都很简单。 使用安装dva-cli1npm install dva-cli -g 创建新应用1dva new dva-quickstart 这是目前会出现的安装问题,在github上面，作者也没有给出详细的解决方案 这里你开始使用这种方式安装umi 从而解决dva的安装问题 解决方案 如果没有上面的情况的话自己的电脑没有成功，但是使用公司的电脑就成功了，步骤是一样的，但是自己的电脑就是创建不了，蛋疼的很。 models 目录effects:{}副作用，都是用来存放异步函数.动作操作,用来操作reducers,返回新数据更新视图. call使用方法: 1const &#123;a,b&#125;=yield call(services里的接口函数,&#123;参数&#125;) put使用方法: 1234yield put(&#123; type:&quot;effect里的方法或者reducers里的方法名&quot;, payload:&#123;参数&#125;&#125;) select使用方法： 1const name=yield select(state=&gt;state.namespace) take使用方法: 1yield take(&apos;a&apos;)]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七天]]></title>
    <url>%2F2019%2F04%2F22%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%B8%83%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Redux 的学习Redux基本介绍 单项数据流:从父组件流向子组件，兄弟组件无法共享数据 State: React中的状态，是只读对象，不可直接修改 Reducer：基本函数，用于对State的业务处理 Action: 普通对象，用于描述事件行为，改变State Redux安装123yarn add redux --saveyarn add react-redux --save Redux 不单单为React提供服务的 Redux集承 创建Action模块 创建Reducer模块 创建Store模块 通过connect方法将React组件和Redux连接起来 添加Provider作为项目的根组件，用于数据的存储 Redux调试工具安装 首先在 Chrome中安装Redux Devtools扩展 yarn add redux-devtools-extension Redux有点难 暂时放弃OM前端例会 4-22看看我们能做一些 自己的东西 除了我们项目之外的东西 对象存储和实时下载服务 对象就是一个东西，图片，音频，视频等非结构化数据的数据池 文件的下载 ，尽量在后端生成传送给前端， 前端导出 实现这样一个需求一个导出按钮，对表格的数据进行导出。 PS1支持最多导出一周数据，可导出最早数据可追溯至30天前 需求详解:1每点击一次按钮，就会导出7天的数据，倘若7天内包括了30天的临界值，这时候只要求在临界值内的数据导出。 研发分析: 1查看没有限制，但是如果导出的话，每次最多只能导出一周的数据，那么就每次查询一周，然后导出]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六天]]></title>
    <url>%2F2019%2F04%2F21%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%85%AD%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[早上张凯就走了。下午的时候张硕来了 来的时候让我给他叫外卖，夜里让我请他吃饭。。。。。。 下午去自己出租屋，把自己的箱子给带过来。本来想是骑着共享单车回来的，但是这个箱子太大了，非常的不方便，而且感觉很容易出危险，安全起见，自己还是走着回去吧。 夜里的时候，张硕就准备自己的算法，应对明天的京东面试，京东的面试是真的晚，四月中旬，感觉时间不是特别好，刚好就在今天，刘强东性侵事件的视频发布出来，果真是仙人跳。这个猜都不用猜，女的肯定是诬告。 顿时觉得京东的股票会上涨，然后就觉得，他们这次面试应该就没问题了。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五天]]></title>
    <url>%2F2019%2F04%2F20%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%BA%94%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[昨天还特意问了对面的哥们，今天用来上班不。他的回答很肯定：不用，我们不是996 今天的任务就是把房子给找了。中午和中介联系； 他带着我去看了几套房子。 第一套：2100/月环境差，五家合住，里面的桌子我都不忍直视，脏！那个床，我靠，用一个脏字我都形容不了。果断放弃，出门看到这个房子出售，那个价格，惊呆了，730W,就那破房子，730W，你敢信，这就是北京 第二套:2400/月这个是三家合住，进入以后，感觉还是有点小，因为自己想留个大的地方，锻炼锻炼。并且环境有点差，所以也就放弃了，并且这套房子有点偏，左拐右拐，又是坐电梯又是走楼梯的受不了。 第三套:2800/月这个房子其实在微信上就已经看上了，装扮还是比较好的，最终看了以后就选择这套，后面的房子也就懒得看了。因为都比这个贵。 签约房东刚好就住在这个房间，是一个二房东，每天2元的管理费和网费(用的话)，每个月就是120，电费一加，差不多每个月3000. 后来居然发现自己的钱居然不够了，不得已向其他人借点。中介费1200 给多了。中介是真的赚钱，如果我能直接联系到这个二房东就不用掏这个钱，中介也骑个电驴拉着我转几圈，1200到手(还是我砍价的情况) 下午的时候张凯就来了，他被他导师给坑惨了，刚来公司就被叫回去完成毕设。酒店才住了几天啊，后来和我商量把他的东西放我这里，这样他就不用在拿回去了。 夜里吃 鱼你在一起，蛮划算的。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四天]]></title>
    <url>%2F2019%2F04%2F19%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E5%9B%9B%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[今天主要都花费在看视频上面，慕课网的那个视频还是作用蛮大的，不过视频的时间挺长的。感觉要花费大量的时间在这个项目上， 今天就给大家讲一讲moment时间插件 moment插件支付宝的AntD这个UI组件库明确的写出日期插件的使用要配合moment来使用 12注意：DatePicker、MonthPicker、RangePicker、WeekPicker 部分 locale 是从 value 中读取，所以请先正确设置moment 的 locale。 123456// 默认语言为 en-US，如果你需要设置其他语言，推荐在入口文件全局设置 localeimport moment from &apos;moment&apos;;import &apos;moment/locale/zh-cn&apos;;moment.locale(&apos;zh-cn&apos;);&lt;DatePicker defaultValue=&#123;moment(&apos;2015-01-01&apos;, &apos;YYYY-MM-DD&apos;)&#125; /&gt; 如何使用momentmoment的使用其实还是很简单的 安装moment 导入moment 使用moment 安装1234yarn add moment或者 npm install moment两者都可以安装moment 导入1import moment from &apos;moment&apos; 使用如果你想要得到当前的时间，并且时间的格式为2019-04-23之类的，你就这样写12let newDate=moment().format(&apos;YYYY-MM-DD&apos;)//2019-04-23 这里只是简单的介绍这一种，详细的可以查看文档]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三天]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[es6的结构赋值，相当于把对象中给的各个对象放到你使用结构赋值的地方 123456789101112131415161718192021let obj=&#123; age:1, name:2, person:&#123;&#125; .......代表有很多对象&#125;这时候某个标签或者属性的值正好是obj里面各个属性或者对象,如果我们将obj里面的属性放到其中，这样就会显的冗余，而且很麻烦function add(age=1,name=2,person.....)这样的写法就很繁琐，但是里面不能够这样写function add(obj)这两者是不同的，我们使用解构赋值的方式function add(&#123;...obj&#125;)这样就和所规定的方式是一样的]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二天]]></title>
    <url>%2F2019%2F04%2F17%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[昨天因为自己权限的问题，自己并不能克隆代码进行查看。 今天自己的账号才被激活，然后自己才能拉取代码进行查看。 果然不出我所料，今天导师就然我查看代码(我的技术栈是Vue 代码是React)，幸好自己在入职前学习一段时间的React，大部分的代码还是能够看懂的，具体的代码可能理解起来非常困难，但是那些页面对应那些代码自己还是能够看懂的。 组件化看了大概的代码给自己的感受就是代码完全组件化，工程化。 其实倘若让我开发这个项目的时候，我是不会这样开发的。这里是说我一个人单独的开发，并不是团队开发啊。 组件化和工程化下拉，代码的文件会非常的多，考验一个人对编辑器的掌控能力这时候就体现出来了，不然你查找对应的模块将是一件非常巨大的事情的。 举一些组件化的例子就拿AntD这个组件库来说吧，很多的地方按钮的样式需要自己包装一下，如果我们不将这个按钮封装一下的话，就意味着我们每次使用都需要在开发页面自己包装，最终下来代码很臃肿。 不过这个有一个好处，就是不需要浏览大量的文件(追踪到最后的基础组件),在一个页面就能知道该功能实现的是什么需求。不过当你了解各个参数以后，这个好处就荡然无存了，对刚接触代码的新人友好，时间长了新人也会变成老人，这就不友好了。 react的组件化利用的就是父子组件传值需要的数据一层一层的传递下去，不过传递的层数最好不要超过三层，不然很麻烦]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一天]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%B9%85%E5%8E%82%E5%AE%9E%E4%B9%A0%2F%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[昨天夜里并没有睡好觉，因为今天是一个特殊的日子，今天4-16号是我入职腾讯的第一天。 早上的时候我和同住在宾馆的张凯就在讨论是否早点过去，避免让人家久等，毕竟在邮件上写的是早上九点半报道。虽然他说无所谓，最后还是九点半到达地方。 到达地方以后发现自己想多了，我以为入职的人并不是很多，并且每个人都会有一个hr小姐姐带领你逛一逛公司并且带你去办理一下入职资料。 谁知道就是排队，一个一个解决自己的入职报到。 入职大约花费一上午，并且自己的工卡还没有制作，还有等待3-4天。 办理结束以后刚好12点，联系好自己的导师，约定时间是下午两点报到，工卡没有 真的很难受。 下午先把自己的电脑给组装好，然后相应的环境给配置成功。 接着就开始浏览我们组的业务开发流程，一个巨大无比的文档，自己开始浏览。 导师也没说具体看那部分，自己就东看看西看看，最终知道这到底是个啥玩意。 吃完饭，就自己看看业务。。。 一天的时间就这样过去了]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>-实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(二)JavaScript常用数组操作方法，包含ES6方法]]></title>
    <url>%2F2018%2F12%2F31%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F(%E4%BA%8C)JavaScript%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8C%85%E5%90%ABES6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一 concat()concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。123456var arr1 = [1, 2, 3]var arr2 = [4, 5]var arr3 = arr1.concat(arr2)console.log(arr1) //[ 1, 2, 3 ]console.log(arr2) //[4,5]console.log(arr3) //[1,2,3,4,5] 二 join()join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用’,’号分割，不改变原数组。123456var arr = [2, 3, 4]var s = arr.join(&quot;|&quot;)var s1 = arr.join()console.log(s) //2|3|4console.log(s1) //2,3,4console.log(arr) //[ 2, 3, 4 ] 三 push()push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。123456789var a = [1, 2, 3, 4]var b = a.push(6)console.log(a) //[ 1, 2, 3, 4, 6 ]console.log(b) //5 //push可以一次添加多个元素var a1 = [1]a1.push(2, 3, 4, 5, 6)console.log(a1) //[ 1, 2, 3, 4, 5, 6 ] 四 pop()pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。123var arr = [1, 2, 3]console.log(arr.pop())//3console.log(arr)//[1,2] 五 unshift()unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。123var arr = [1, 2, 3]console.log(arr.unshift(8, 8, 8)) //6console.log(arr) //[ 8, 8, 8, 1, 2, 六 shift()shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。123var arr = [1, 2, 3]console.log(arr.shift()) //1console.log(arr) //[2,3] 七 slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组1234var arr = [1, 2, 3, 4, 5]console.log(arr.slice(1, 3)) //[2,3]console.log(arr.slice(1)) //[ 2, 3, 4, 5 ]console.log(arr) //[1,2,3,4,5] 八 splice()splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。12345678var a = [2, 3, 4, 5]//1 是删除的起始位置 2是删除的长度，9就添加的元素console.log(a.splice(1, 2, 9)) //[ 3, 4 ]console.log(a) //[ 2, 9, 5 ]var b = [1, 2, 3, 4, 5]console.log(b.splice(1, 3)) //[ 2, 3, 4 ]console.log(b) //[1,5] 九 sort 排序按照 Unicode code 位置排序，默认升序1234567var arr = [&quot;chec&quot;, &quot;apple&quot;, &quot;banner&quot;]console.log(arr.sort()) //[ &apos;apple&apos;, &apos;banner&apos;, &apos;chec&apos; ]console.log(arr) //[ &apos;apple&apos;, &apos;banner&apos;, &apos;chec&apos; ]var arr1 = [1, 2, 10, 99, 31]console.log(arr1.sort()) //[ 1, 10, 2, 31, 99 ]console.log(arr1) //[ 1, 10, 2, 31, 99 ] sort 对数字进行排序的时候，需要自己写函数当做参数传递到 sort 里面，因为当数字是多位的时候，它默认是按照第一位进行排序的，也就是 1&gt;33 的123var arr = [1, 55, 44, 2, 8, 7, 56]arr.sort((x, y) =&gt; x - y)console.log(arr) //[ 1, 2, 7, 8, 44, 55, 56 ] 十 reverse()reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组123var arr = [2, 3, 4, 5]console.log(arr.reverse()) //[ 5, 4, 3, 2 ]console.log(arr) //[ 5, 4, 3, 2 ] 十一 indexOf 和 lastIndexOf都接受两个参数：查找的值、查找起始位置不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。indexOf1234var a = [1, 5, 4, 7, 4, 8, 9]console.log(4) //2console.log(a.indexOf(4, 3)) //4console.log(a.indexOf(10)) //-1 lastIndexOf返回的索引值都是数组的索引，并不因为从后或者从前搜索而改变索引值。lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 123var a = [1, 5, 4, 7, 4, 8, 9]console.log(a.lastIndexOf(4)) //4console.log(a.lastIndexOf(4, 3)) //2 十二 every()对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true12345678//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var a = [2, 3, 4, 7, 9]var b = [19, 2, 4, 5, 6]console.log(a.every(isBig)) //trueconsole.log(b.every(isBig)) //false 十三 some()对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true12345678910//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var a = [2, 3, 4, 7, 9]var b = [19, 2, 4, 5, 6]var c = [11, 23, 44, 55, 66]console.log(a.some(isBig)) //trueconsole.log(b.some(isBig)) //trueconsole.log(c.some(isBig)) //false 十四 filter()对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组1234567//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var b = [19, 2, 4, 5, 6]console.log(b.filter(isBig)) //[ 2, 4, 5, 6 ] 十六、map()对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组1234567//element数组中的每个元素function isBig(element) &#123; return element * 2;&#125;var a = [2, 3, 4, 7, 9]console.log(a.map(isBig)) //[ 4, 6, 8, 14, 18 ] 十七、forEach 数组遍历123456789var a = [1, 2, 3, 4]a.forEach(item =&gt; &#123; console.log(item)&#125;)//1234 下面的都是 ES6 新增的方法1、find()：find 方法是从数组中查找。在 find 方法中我们需要传入一个匿名函数,找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索，函数需要传入三个参数： value ：表示当前查找的值 index : 表示当前查找的数组索引 arr : 表示当前数组 123let arr = [1, 2, 3, 4]console.log(arr.find((value, index, arr) =&gt; value &gt; 2)) //3 2、findIndex()传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。12let arr = [1, 2, 3, 4]console.log(arr.findIndex((value, index, arr) =&gt; value &gt; 2)) //2 3、fill()用新元素替换掉数组内的元素，可以指定替换下标范围，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。123let arr=[0,1,2,3,4,5,6,7,8,9];arr.fill(&apos;javascript&apos;,2,4);console.log(arr);//[0, 1, &quot;javascript&quot;, &quot;javascript&quot;, 4, 5, 6, 7, 8, 9] 4、copyWithin()选择数组的某个下标，从该位置开始复制数组元素，默认从 0 开始复制。也可以指定要复制的元素范围。(在当前数组内部，将指定位置的成员复制到其他位置，返回当前数组。)参数: 第一个参数（从该位置开始替换数据） 第二个参数（可选 从该位置开始读取数据，默认为 0，负值表示倒数）； 第三个参数（可选 到该位置前停止读取，默认为数组长度） 1234567891011121314151617// 将 3 号位复制到 0 号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2 相当于 3 号位， -1 相当于 4 号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将 3 号位复制到 0 号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将 2 号位到数组结束，复制到 0 号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 5、fromArray.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有 length 属性的对象。123456let json = &#123; &apos;0&apos;: &apos;JSfe&apos;, &apos;1&apos;: &apos;温情也&apos;, &apos;2&apos;: &apos;大大&apos;, length: 3&#125; 这就是一个标准的 JSON 数组格式，跟普通的 JSON 对比是在最后多了一个 length 属性。只要是这种特殊的 json 格式都可以轻松使用 ES6 的语法转变成数组。在 ES6 中绝大部分的 Array 操作都存在于 Array 对象里。我们就用 Array.from(xxx)来进行转换。我们把上边的 JSON 代码转换成数组，并打印在控制台。 12345678let json = &#123; &apos;0&apos;: &apos;JSfe&apos;, &apos;1&apos;: &apos;温情也&apos;, &apos;2&apos;: &apos;大大&apos;, length: 3&#125;let arr = Array.from(json);console.log(arr) //[ &apos;JSfe&apos;, &apos;温情也&apos;, &apos;大大&apos; ] 6、of它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用 eval 来进行转换，如果你一个老手程序员都知道 eval 的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用 Array.of 方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12let arr = Array.of(3, 4, 5, 6);console.log(arr); //[ 3, 4, 5, 6 ] 用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。 1234console.log(Array()) //[]console.log(Array(3)) //[,,,][ &lt;3 empty items&gt; ]console.log(Array(1, 2, 3)) //[ 1, 2, 3 ]console.log(Array.of(2)) //[ 2 ] 7、for of 循环1234let arr = [1, 2, 3, 4]for (let item of arr) &#123; console.log(item)&#125;//1 2 3 4 8、entries() 返回迭代器：返回键值对一个新的 Array 迭代器对象。Array Iterator 是对象，它的原型（proto:Array Iterator）上有一个 next 方法，可用用于遍历迭代器取得原数组的[key,value]。 12345678910let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.entries()) &#123; console.log(e)&#125;/** * [0, &apos;a&apos;] [1, &apos;b&apos;] [2, &apos;c&apos;] **/ 9、values() 返回迭代器：返回键值对的 value12345let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.values()) &#123; console.log(e)&#125; //a b c 10、keys() 返回迭代器：返回键值对的 key1234let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.keys()) &#123; console.log(e)&#125; //1 2 3 11、includes判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误一 concat()concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。123456var arr1 = [1, 2, 3]var arr2 = [4, 5]var arr3 = arr1.concat(arr2)console.log(arr1) //[ 1, 2, 3 ]console.log(arr2) //[4,5]console.log(arr3) //[1,2,3,4,5] 二 join()join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用’,’号分割，不改变原数组。123456var arr = [2, 3, 4]var s = arr.join(&quot;|&quot;)var s1 = arr.join()console.log(s) //2|3|4console.log(s1) //2,3,4console.log(arr) //[ 2, 3, 4 ] 三 push()push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。123456789var a = [1, 2, 3, 4]var b = a.push(6)console.log(a) //[ 1, 2, 3, 4, 6 ]console.log(b) //5 //push可以一次添加多个元素var a1 = [1]a1.push(2, 3, 4, 5, 6)console.log(a1) //[ 1, 2, 3, 4, 5, 6 ] 四 pop()pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。123var arr = [1, 2, 3]console.log(arr.pop())//3console.log(arr)//[1,2] 五 unshift()unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。123var arr = [1, 2, 3]console.log(arr.unshift(8, 8, 8)) //6console.log(arr) //[ 8, 8, 8, 1, 2, 六 shift()shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。123var arr = [1, 2, 3]console.log(arr.shift()) //1console.log(arr) //[2,3] 七 slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组1234var arr = [1, 2, 3, 4, 5]console.log(arr.slice(1, 3)) //[2,3]console.log(arr.slice(1)) //[ 2, 3, 4, 5 ]console.log(arr) //[1,2,3,4,5] 八 splice()splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。12345678var a = [2, 3, 4, 5]//1 是删除的起始位置 2是删除的长度，9就添加的元素console.log(a.splice(1, 2, 9)) //[ 3, 4 ]console.log(a) //[ 2, 9, 5 ]var b = [1, 2, 3, 4, 5]console.log(b.splice(1, 3)) //[ 2, 3, 4 ]console.log(b) //[1,5] 九 sort 排序按照 Unicode code 位置排序，默认升序1234567var arr = [&quot;chec&quot;, &quot;apple&quot;, &quot;banner&quot;]console.log(arr.sort()) //[ &apos;apple&apos;, &apos;banner&apos;, &apos;chec&apos; ]console.log(arr) //[ &apos;apple&apos;, &apos;banner&apos;, &apos;chec&apos; ]var arr1 = [1, 2, 10, 99, 31]console.log(arr1.sort()) //[ 1, 10, 2, 31, 99 ]console.log(arr1) //[ 1, 10, 2, 31, 99 ] sort 对数字进行排序的时候，需要自己写函数当做参数传递到 sort 里面，因为当数字是多位的时候，它默认是按照第一位进行排序的，也就是 1&gt;33 的123var arr = [1, 55, 44, 2, 8, 7, 56]arr.sort((x, y) =&gt; x - y)console.log(arr) //[ 1, 2, 7, 8, 44, 55, 56 ] 十 reverse()reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组123var arr = [2, 3, 4, 5]console.log(arr.reverse()) //[ 5, 4, 3, 2 ]console.log(arr) //[ 5, 4, 3, 2 ] 十一 indexOf 和 lastIndexOf都接受两个参数：查找的值、查找起始位置不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。indexOf1234var a = [1, 5, 4, 7, 4, 8, 9]console.log(4) //2console.log(a.indexOf(4, 3)) //4console.log(a.indexOf(10)) //-1 lastIndexOf返回的索引值都是数组的索引，并不因为从后或者从前搜索而改变索引值。lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 123var a = [1, 5, 4, 7, 4, 8, 9]console.log(a.lastIndexOf(4)) //4console.log(a.lastIndexOf(4, 3)) //2 十二 every()对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true12345678//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var a = [2, 3, 4, 7, 9]var b = [19, 2, 4, 5, 6]console.log(a.every(isBig)) //trueconsole.log(b.every(isBig)) //false 十三 some()对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true12345678910//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var a = [2, 3, 4, 7, 9]var b = [19, 2, 4, 5, 6]var c = [11, 23, 44, 55, 66]console.log(a.some(isBig)) //trueconsole.log(b.some(isBig)) //trueconsole.log(c.some(isBig)) //false 十四 filter()对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组1234567//element数组中的每个元素 index索引 array数组对象function isBig(element, index, array) &#123; return element &lt; 11;&#125;var b = [19, 2, 4, 5, 6]console.log(b.filter(isBig)) //[ 2, 4, 5, 6 ] 十六、map()对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组1234567//element数组中的每个元素function isBig(element) &#123; return element * 2;&#125;var a = [2, 3, 4, 7, 9]console.log(a.map(isBig)) //[ 4, 6, 8, 14, 18 ] 十七、forEach 数组遍历123456789var a = [1, 2, 3, 4]a.forEach(item =&gt; &#123; console.log(item)&#125;)//1234 下面的都是 ES6 新增的方法1、find()：find 方法是从数组中查找。在 find 方法中我们需要传入一个匿名函数,找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索，函数需要传入三个参数： value ：表示当前查找的值 index : 表示当前查找的数组索引 arr : 表示当前数组 123let arr = [1, 2, 3, 4]console.log(arr.find((value, index, arr) =&gt; value &gt; 2)) //3 2、findIndex()传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。12let arr = [1, 2, 3, 4]console.log(arr.findIndex((value, index, arr) =&gt; value &gt; 2)) //2 3、fill()用新元素替换掉数组内的元素，可以指定替换下标范围，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。123let arr=[0,1,2,3,4,5,6,7,8,9];arr.fill(&apos;javascript&apos;,2,4);console.log(arr);//[0, 1, &quot;javascript&quot;, &quot;javascript&quot;, 4, 5, 6, 7, 8, 9] 4、copyWithin()选择数组的某个下标，从该位置开始复制数组元素，默认从 0 开始复制。也可以指定要复制的元素范围。(在当前数组内部，将指定位置的成员复制到其他位置，返回当前数组。)参数: 第一个参数（从该位置开始替换数据） 第二个参数（可选 从该位置开始读取数据，默认为 0，负值表示倒数）； 第三个参数（可选 到该位置前停止读取，默认为数组长度） 1234567891011121314151617// 将 3 号位复制到 0 号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2 相当于 3 号位， -1 相当于 4 号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将 3 号位复制到 0 号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将 2 号位到数组结束，复制到 0 号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 5、fromArray.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有 length 属性的对象。123456let json = &#123; &apos;0&apos;: &apos;JSfe&apos;, &apos;1&apos;: &apos;温情也&apos;, &apos;2&apos;: &apos;大大&apos;, length: 3&#125; 这就是一个标准的 JSON 数组格式，跟普通的 JSON 对比是在最后多了一个 length 属性。只要是这种特殊的 json 格式都可以轻松使用 ES6 的语法转变成数组。在 ES6 中绝大部分的 Array 操作都存在于 Array 对象里。我们就用 Array.from(xxx)来进行转换。我们把上边的 JSON 代码转换成数组，并打印在控制台。 12345678let json = &#123; &apos;0&apos;: &apos;JSfe&apos;, &apos;1&apos;: &apos;温情也&apos;, &apos;2&apos;: &apos;大大&apos;, length: 3&#125;let arr = Array.from(json);console.log(arr) //[ &apos;JSfe&apos;, &apos;温情也&apos;, &apos;大大&apos; ] 6、of它负责把一堆文本或者变量转换成数组。在开发中我们经常拿到了一个类似数组的字符串，需要使用 eval 来进行转换，如果你一个老手程序员都知道 eval 的效率是很低的，它会拖慢我们的程序。这时候我们就可以使用 Array.of 方法。我们看下边的代码把一堆数字转换成数组并打印在控制台上：12let arr = Array.of(3, 4, 5, 6);console.log(arr); //[ 3, 4, 5, 6 ] 用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。 1234console.log(Array()) //[]console.log(Array(3)) //[,,,][ &lt;3 empty items&gt; ]console.log(Array(1, 2, 3)) //[ 1, 2, 3 ]console.log(Array.of(2)) //[ 2 ] 7、for of 循环1234let arr = [1, 2, 3, 4]for (let item of arr) &#123; console.log(item)&#125;//1 2 3 4 8、entries() 返回迭代器：返回键值对一个新的 Array 迭代器对象。Array Iterator 是对象，它的原型（proto:Array Iterator）上有一个 next 方法，可用用于遍历迭代器取得原数组的[key,value]。 12345678910let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.entries()) &#123; console.log(e)&#125;/** * [0, &apos;a&apos;] [1, &apos;b&apos;] [2, &apos;c&apos;] **/ 9、values() 返回迭代器：返回键值对的 value12345let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.values()) &#123; console.log(e)&#125; //a b c 10、keys() 返回迭代器：返回键值对的 key1234let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]for (let e of arr.keys()) &#123; console.log(e)&#125; //1 2 3 11、includes()判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误1234var a = [1, 2, 3]console.log(a.includes(1))//trueconsole.log(a.includes(5))//false]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一)史上最全的JavaScript变量类型和计算的介绍]]></title>
    <url>%2F2018%2F12%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F(%E4%B8%80)%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84JavaScript%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[123456我写这篇文章的原因：我在复习的时候，阅读很多博客发现很多我没有听过的名称，比如原始类型，对象类型等，搞得我一头雾水。我所了解的数据类型不就string number之类的，但是我也不是很清楚他们属于哪个阵营吧。但是我知道基本数据类型和引用类型。这原始类型和对象类型是从哪里冒出来的？随后我在网上搜索了N篇文章，重要搞清楚这些概念。其实很多名字都是指向一个东西，只是叫法不一样。比如你叫张三，小名狗蛋。你村里人叫张三是你，叫狗蛋还是你。那么基本数据类型和原始类型其实是一样的。 一，变量分类在 JavaScript 六种数据类型分为两大类 基本数据类型(原始类型) 字符串 String 数字 Number 布尔 Boolean 空值 Null 未定义 Undefined 唯一值(ES6) Symbol 首先原始类型(基本数据类型)存储的都是值，是没有函数可以调用的，比如 undefined.toString()但是你看到这里你会有疑问，为什么”2”.toString()可以呢，其实这种情况下，”2”已经不是原始类型了，而是被强制转成了 String 类型，也就是对象类型，所以可以调用 toString 函数。 typeof 来检测原始类型12345678910//typeof运算类型 只能区分值类型console.log(typeof undefined) //undefinedconsole.log(typeof &quot;abc&quot;) //stringconsole.log(typeof &quot;undefined&quot;) //stringconsole.log(typeof 123) //numberconsole.log(typeof true) //booleanconsole.log(typeof &#123;&#125;) //objectconsole.log(typeof []) //objectconsole.log(typeof null) //object null是引用类型console.log(typeof console.log) //function 另外对于 null 来说，很多人认为他是一个对象类型，其实这是错误的，null 就是原始类型也就是值类型。你看到网上很多的博客对 null 的描述都是错误的。typeof null 会输出 object 是 JS 存在的一个 bug。在 JS 的最初版本中使用的是 32 位系统。为了性能考虑使用低位存储变量信息，000 开头代表对象，然而 null 表示全零。所以将它错误的判断为 object。虽然现在的内部类型判断代码已经改变，但是这个 bug 一直存在。 引用数据类型(对象类型) Object(在 JS 中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象) 1.Array2.Boolean3.Date4.Number5.String6.RegExp7.function上面的都是引用类型，都包含在 object 中。 instanceof 检测引用类型 typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的 1234567891011121314151617181920212223242526272829303132333435363738394041//instanceof检测let a = [1, 2]console.log(a instanceof Array) //trueconsole.log(a instanceof Object) //truelet s = &quot;ss&quot;console.log(s instanceof String) //falseconsole.log(s instanceof Object) //falselet s1 = new String(&quot;Hello&quot;)console.log(s1) //[String: &apos;Hello&apos;]console.log(s1 instanceof String) //trueconsole.log(s1 instanceof Object) //truelet t = trueconsole.log(t instanceof Boolean) //falseconsole.log(t instanceof Object) //falselet t1 = new Boolean(true)console.log(t1) //[Boolean: true]console.log(t1 instanceof Boolean)console.log(t1 instanceof Object)let func = function() &#123;&#125;console.log(func instanceof Function) //trueconsole.log(func instanceof Object) //truelet rex = /^[1-9]/console.log(rex instanceof RegExp) //trueconsole.log(rex instanceof Object) //truelet date = new Date()console.log(date instanceof Date) //trueconsole.log(date instanceof Object) //true 注意上面显示的地方有几个是 false，因为那两个的创建方式并不是对象类型的创建方式，是原始类型的创建。instanceof 是不能检测出来原始类型的，所以那里显示的是 false。 123456class PrimitiveString &#123; static [Symbol.hasInstance](x) &#123; return typeof x === &apos;string&apos; &#125;&#125;console.log(&apos;hello world&apos; instanceof PrimitiveString) // true 你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof ‘hello world’ === ‘string’，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的 二，原始类型和对象类型的区别在 JS 中，除了原始类型那么其他的都是对象类型。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址。当你创建一个对象类型的时候，计算机会在内存中帮我们开辟一个空间存放值，但是我们需要找到这个空间，这个空间就会拥有一个地址。还有就是引用变量就是值引用(改变指针的指向位置)，多个变量公用一个内存块，减少空间的浪费。引用类型1let a=[] 对于常量 a 来说，假设内存地址是#111,那么在地址#111 的位置存放了值[]，常量 a 存放了地址#111。在看下面的代码 12345let a=[]let b=ab.push(1)console.log(a)//[1]console.log(b)//[1] 当我们将变量赋值给另一个变量时，赋值的是原本变量的地址，也就是说当前变量存放的地址也是#111,当我们进行数据修改的时候，就会修改存放在地址#111 上的值，也就导致两个变量的值都会发生变化 原始类型1234let s = &quot;ad&quot;let s1 = ss1 = &quot;aaa&quot;console.log(s1, s)//aaa ad 看第二行的代码，是把 s 的值”ad”赋值给 s1，赋值完成以后 s 和 s1 就没有什么联系，因此修改二者中的任何一个，对另外一个都不会产生影响。 三，函数参数是对象12345678910111213141516function test(person) &#123; person.age = 26 person = &#123; name: &apos;fff&apos;, age: 18 &#125; return person&#125;const p1 = &#123; name: &apos;aaa&apos;, age: 26&#125;const p2 = test(p1)console.log(p1) // &#123; name: &apos;aaa&apos;, age: 26 &#125;console.log(p2) // &#123; name: &apos;fff&apos;, age: 18 &#125; 首先，函数传参是传递对象指正的副本 到函数内部修改参数的属性这部，当前 p1 的值也被修改了 但是当我们重新为 person 分配了一个对象时，就出现了分歧请看下图最后 person 拥有了一个新的地址，也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的 四，类型转换在 JS 中类型转换只有三种情况，分别是:1.转换为布尔值2.转换为数字3.转换为字符串先看下图： 强制类型转换(下面的情况会产生类型转换)1.字符串拼接 12ler a=1+1 //2let b=1+&quot;1&quot;//11 ==运算符（慎用） 123console.log(100 == &quot;100&quot;) //trueconsole.log(0 == &quot;&quot;) //trueconsole.log(null == undefined) //true if 语句在条件判断的时候，处理 undefined,null,false,NaN,””,0,-0 其他所有值都会转为 true，包括所有对象 12345678910111213var a = trueif (a) &#123; console.log(&quot;a&quot;) //a&#125;var b = 100if (b) &#123; console.log(&quot;b&quot;) //b&#125;var c = &quot;&quot; //不运行if (c) &#123; console.log(&quot;c&quot;)&#125; 4.逻辑运算 1234567//逻辑运算符console.log(10 &amp;&amp; 0) //0console.log(10 || 0) //10console.log(&apos;&apos; &amp;&amp; &apos;abc&apos;) //空值console.log(&apos;&apos; || &apos;abc&apos;) //abcvar a = 100console.log(!!a) //true !a=fasle !!a=true 四则运算符加法运算符不同于其他几个运算符，它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 123console.log(1 + &quot;1&quot;)//11console.log(true + true)//2console.log(4 + [1, 2, 3])//41,2,3 解析: 第一行代码，触发类型 3,会将数字 1 转换为字符串，得到的结果”11” 第二行代码，触发类型 1,会将布尔值转换为数字，得到的结果是 2 第三行代码，触发类型 3,会将数组转换为字符串(通过 toString()方法)1,2,3 得到的结果是 41,2,3. 另外对于加法还需要注意这个表达式”a”++”b”1console.log(&quot;a&quot; + +&quot;b&quot;) //aNaN 因为+’b’等于 NaN，所以结果是”aNaN” 除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转换为数字1234console.log(4 * &quot;3&quot;)//12console.log(4 * [])//0console.log(4 * [1, 2])//NaN 比较运算符1.如果是对象，就通过 toPrimitive 转换为对象2.如果是字符串，就通过 unicode 字符索引比较 1234let a = &quot;a&quot;let b = &quot;b&quot;console.log(a &gt; b) //falseconsole.log(b &gt; a) //true 何时使用 = = =何时使用= =当 obj.a= =null 的时候用= =其他情况全部用= = =obj.a= =null 相当于 obj.a= = =null || obj.a= == undefined 留下一个小问题：true+true(如果一方不是字符串或者数字，那么会将它转换为数字或者字符串)的结果为什是 2 却不是’truetrue’，如果知道的话可以在下方留言告诉我]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS滑动窗口的最大值]]></title>
    <url>%2F2018%2F12%2F28%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个数组 nums，有一个大小为 k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k内的数字。滑动窗口每次只向右移动一位。返回滑动窗口最大值。 123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7]解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 方案一 暴力傻方法第一次遇到自己写出的算法时间居然上千 ms，震惊至极。而且空间复杂度也很高。给大家讲一讲思路大家很容易想到的一种方法，就是前 K 个元素进入窗口以后，我们对它进行排序，然后找到最后一个就可以，随后的 nums.length-k 个元素，每进入一个，我们就把窗口最前面的那个元素抛出，假如一个新的元素，然后行进重复的操作，排序，找到最后一个。因为每次排序会改变数组，所以这里你需要一个另外一个数组来存放排序前的数组。在算法的前面你可以进行判断一下，如果 k=1，那么你就可以直接返回原数组.nums=[]直接返回空就可以12345678910111213141516171819202122var maxSlidingWindow = function(nums, k) &#123; if (nums.length == 0) &#123; return [] &#125; if (k == 1) return nums let window = [] let window1 = [] let res = [] for (let i = 0; i &lt; k; i++) &#123; window.push(nums[i]) &#125; window1 = window.slice() window.sort((x, y) =&gt; x - y) res.push(window[k - 1]) for (let i = k; i &lt; nums.length; i++) &#123; window1.shift() window1.push(nums[i]) window = window1.slice() window1.sort((x, y) =&gt; x - y) res.push(window1[k - 1]) window1 = window &#125; return res&#125;; 上面算法的复杂度我给大家计算下啊，首先每次进入一个数据，都要进行 sort 排序，sort 用最快的快排，其时间复杂度是 nlogn 的，进入 n 个数的话就是 n²logn 很大了 方案二 采用双向队列12345678910111213141516看题中给的数据 1 3 -1 -3 5 3 6 7我们给一个窗口队列，来存放进入的数据首先是1进入，队列为[1]，然后3进入，这时候3进入的时候先和它前面的数据进行比较，发现3&gt;1，这时候把队列中1抛出这时候-1进入队列，发现-1小于3，所以-1进入以后不进行任何操作。这时候队列为[3,-1]这时候其实窗口的大小已经为3啦因为我们前面抛出一个1所以看着是两个数据。然后-3进入，这时候就要判断，窗口队列的长度是不是大于k，当大于k的时候就要把队列的首元素抛出。-3进入的时候，明显长度没有超出，所以不用管，然后-3和队尾元素比较，小于队尾。进入队里无操作。这时候队列是[3,-1,-3],随后5进入，这时候，队列的长度大于k，把队列头元素3抛出，然后进行判断，发现5比队尾元素大，这时候抛出队尾的-3，这时候队尾元素变成-1，5还是大于-1，继续抛出，这时候队列中只有[5].然后6准备进入。发现6大于队尾5,5抛出，6进入。7的操作同上。 上面的操作结果为：队列的头元素永远是最大的，所以后面的(nums.length-k)次进入，只需要队列的头放入输出数组即可，代码如下 index 为下标，window 存放的为下标，item 遍历数组中的元素 1234567891011121314151617181920var maxSlidingWindow = function(nums, k) &#123; if (nums.length == 0) return [] let window = []//队列用来存放下标 let res = [] nums.forEach((item, index) =&gt; &#123; console.log(window, nums[window[0]]) if (index &gt;= k &amp;&amp; window[0] &lt;= index - k) &#123; window.shift()//队列头抛出 &#125; while (window &amp;&amp; nums[window[window.length - 1]] &lt;= item) &#123; window.pop()//队列为抛出 &#125; window.push(index) if (index &gt;= k - 1) &#123; res.push(nums[window[0]]) &#125; &#125;) return res&#125; 来计算时间复杂度，O(n)的操作，因为只有每次进入的时候，有时间复杂度，里面的判断和抛出都是 O(1)的操作]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章让你不再担心浮动]]></title>
    <url>%2F2018%2F12%2F27%2FHTML%2BCSS%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%A9%E4%BD%A0%E4%B8%8D%E5%86%8D%E6%8B%85%E5%BF%83%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动的效果文档流文档流是文档中可显示对象在排列时所占用的位置。将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流.(自己的理解是从头到尾按照文档的顺序，该在什么位置就在什么位置，也可以按照上面的意思理解，自上而下，自左到右的顺序)浮动的特点使元素脱离文档流，按照指定的方向发生移动，遇到父级的边界或者相邻的浮动元素就会停下来 123456781 块元素可以在一行显示2 按照一个指定的方向移动，遇到父级的边界或者相邻的浮动元素就会停下来3 行内元素支持宽高(设置浮动以后就会变成块级元素)4 脱离文档流：1 指元素不在页面当中占位置 2 定位是完全脱离文档流 3 浮动不是完全脱离文档流5 块级元素的默认宽度会被改变(包裹性) 块元素不设置宽高，那宽高会自动变成所撑开的内容6 父级高度塌陷(破坏性)--&gt; 子元素浮动以后，那么父元素的高度就不会自动撑开7 换行不会被解析成空格--&gt;浮动后的元素就会脱离文档流了，那它就不属于文档流的结构了，所以换行和空格都和父级没关系如果高度不一致的情况下，想让他们按顺序排列就可以选择inline-block 浮动的目的为了达到自己的布局目的，让指定元素定位在指定位置，我们就需要用到浮动。包含块想知道浮动的详细内容就必须知道包含块的概念。浮动元素的包含块是其最近的块级祖先元素。如下 P 标签是 img 的包含块而 span 不是。定位也有包含块的概念12&lt;p&gt;&lt;img src=&quot;#&quot; style=&quot;float:left&quot;&gt;&lt;/p&gt;&lt;span&gt;&lt;img src=&quot;#&quot; style=&quot;float:left&quot;&gt;&lt;/span&gt; 控制浮动元素的规则（准确的说就是浮动元素的特性，并不是需要代码实现的内容）1 浮动元素的左或右外边界不能超过其包含块的左或右内边界123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border:1px solid red ; padding: 10px; &#125; .box1&#123; width: 50px; height: 50px; background: red; float: left; margin: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2 浮动元素的左(或右)外边界必须是源文档中之前出现的左浮动(或右浮动)元素的右(左)外边界这个规则的好处：所有的浮动元素都是可见的，不会产生一个浮动元素与另一个浮动元素重叠 3 左(右)浮动元素的右(左)边界不会再其右(左)边右(左)浮动元素的左(右)外边界的右(左)边这个规则也是防止浮动元素产生重叠，父级元素的宽度只有 500px 两个浮动子元素一个浮动在左，一个浮动在右，他们的宽度都是 300px。这时候有浮动的元素就会想下浮动，避免产生重叠 4 浮动元素的顶端不能比之前(前一个浮动元素)或块级元素的顶端更高比如有 A,B,C 三个浮动元素，它们依次出现的次序是 A,B,C,假如 A 浮动元素与顶端的距离为 10px，那么 B 元素与顶端的距离就一定要大于 10px 比如 15px，那么 C 与顶端的距离就一定要大于 15px 5 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高 与 4 有点类似6 浮动元素必须尽可能高地防止7 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。位置越高，就会向右或向左浮动的越远浮动的影响：1 背景不能显示由于浮动产生，如果对父级设置了 CSS background 背景 CSS 背景颜色 或 CSS 背景图片。但是父级元素不能被撑开，所以导致 CSS 背景不能显示。 2 边框不能撑开如果父级元素设置了 CSS 边框属性，子元素设置浮动，父级元素不能被撑开 3 margin padding 设置值不能正确显示由于浮动导致父子级之间设置的 css padding 和 css margin 属性的值不能正确表达，特别是上下边的 padding 和 margin 不能正确显示 4 块状元素，会钻进浮动元素的下面，被浮动元素所覆盖，像这样 5 行内元素，例如文字， 则会环绕在浮动元素的周围，为浮动元素留出空间，像这样 6 浮动元素的父元素坍缩, 像这样： 浮动解决的问题外边距重合问题如果其他元素与此元素(浮动元素)相邻(这表示水平相邻和垂直相邻)，而且这些元素也有外边距，那么这些外边距不会与浮动元素的外边距合并 —CSS 权威指南 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box2&#123; width: 100px; height: 100px; background: green; color: #fff; border: 3px solid #f00; margin-top: 25px; float: left; &#125; .box1&#123; width: 100px; height: 100px; background: green; color: #fff; border: 3px solid #f00; margin-bottom: 25px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浮动前 浮动后 清除浮动1234567891011121314151617181 clear 元素的某个方向上不能有浮动元素 取值：left 元素的左边不能有浮动的元素 right元素的右边不能有浮动的元素 bot 元素的两边都不能有浮动的元素2 给父级添加高度 有时候是不能给父级元素添加高度的，所以这个方法就用不了(父级元素没有高度的情况下)3 inline-block 和上一个效果一样 但是用来以后就没有办法居中4 overflow:hidden 如果子级元素有定位的话，并且这个定位超过了父级的范围，那样的话就看不到了，所以不能加和这个命令5 空标签 空标签是没有内容的，但是它的作用是用来清除浮动的。所以不符合行为，样式，结构分离的标准 （ie6下标签是有一个最小高度19px，解决后也会有2像素的偏差）6 br清除浮动 和上面一样7 after伪类清除浮动(目前最主流的方法) after-代表选择的元素的内容后面 after伪类的内容默认是一个行内元素 content 为设置的内容 第一种 clear原理：添加一个空 div，利用 css 提高的 clear:both 清除浮动，让父级 div 能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空 div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 200px; background: red; border: 1px solid black; &#125; .div1&#123; float: left; &#125; .div2&#123; float: right; &#125; /*1 clear: both; .div3&#123; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二种 父级设置高度 并不能真正清除浮动（看着像是）原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级 div 不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*2、给父级添加高度：没有从根本上解决浮动的问题*/ height: 100px; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第三种 inline-block12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*3、inline-block*/ display: inline-block; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第四种 overflow:hidden原理：必须定义 width 或 zoom:1，同时不能定义 height，使用 overflow:hidden 时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：不能和 position 配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用 position 或对 overflow:hidden 理解比较深的朋友使用。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; /*4、overflow:hidden;*/ overflow: hidden; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第四种的另外 overflow: auto; 但是如果超出产生滚动条第五种 空标签原理和 clear 一样 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!--&lt;!--5、空标签--&gt; &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第六种 br 标签123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 2px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: royalblue; float: left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;!--6、br清除浮动--&gt; &lt;br clear=&quot;all&quot; /&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果和上面一样 第七种 after原理：IE8 以上和非 IE 浏览器才支持:after，原理和方法 2 有点类似，zoom(IE 专有属性)可解决 ie6,ie7 浮动问题 （其他浏览器不用） 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少 CSS 代码。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .parent&#123; border: 1px solid #f00; &#125; .box&#123; width: 100px; height: 100px; background: blueviolet; float: left; color: #fff; &#125; /* * 7、after伪类清除浮动（现在最主流的方法） * */ .box:after&#123; content: &apos;这是伪类生成的内容&apos;; &#125; .clearfix&#123; *zoom:1; &#125; .clearfix:after&#123; content: &apos;&apos;; display: block; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent clearfix&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现 动态分区-首次适应算法和最佳适应算法]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E5%92%8C%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[实验目的 了解动态分区分配方式中使用的数据结构和分配算法，并进一步加深对动态分区存储管理方式及其实现过程的理解。 实验内容(1) 用 C 语言(不会 C 这里就用 JS 实现)分别实现采用首次适应算法和最佳适应算法的动态分区分配过程 alloc( )和回收过程 free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。 (2) 假设初始状态下，可用的内存空间为 640KB，并有下列的请求序列： 1234567891011•作业1申请130KB。•作业2申请60KB。•作业3申请100KB。•作业2释放60KB。•作业4申请200KB。•作业3释放100KB。•作业1释放130KB。•作业5申请140KB。•作业6申请60KB。•作业7申请50KB。•作业6释放60KB。 请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。 思路解析1 首先给大家介绍下首次适应算法和最佳适算法首次适应算法 首次适应算法从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 最佳适应算法 它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。 上面是百度百科给的定义，其实已经解释的很清楚了，我在这里给大家举一个例子。比如你有一个数组-&gt;[6,4,9,5,2,1],里面的数值分别代表空间吧，这时候你有一个物体，只需要占用 2 空间。这时候你使用这个算法，从 6 开始遍历，发现 6 大于你需要的空间，那么这个物体肯定是可以存放的，所以你就选用 6 来存储这个 2 空间的物体，然后 6 空间就会成 4 空间。其实这个 4 空间就算是一个碎片了如果你又来了一个需要 6 空间的物体，然后刚好 6 空间被你用了(只剩下一个 4 空间)，那么只好向下找。这个就是首次适应算法。如果你采用最佳适应算法，那么你需要 2 空间，它从 6 开始遍历，然后找到刚刚适合 2 空间的(或者是距离它并且能装下它的空间)2。这时候就把 2 空间给占用了。如果你需要 4 空间，那么 5 就会被占用，剩下 1 空间。它的缺点就是，会有很多的小碎片。2 切入正题 题目要求是两种方法来实现对这个作业的调度作业的调度有申请和释放，空间同时有空闲分区和占用的分区。这就意味着我们需要先定义两个方法和两个数组空间 firstaddress 是指该作业的首地址。 lastaddress 是该作业的末地址。 length 是指长度 123456789let UseQueue = []// 占用的分区let freeQueue = [&#123; firstAddress: 0, lastAddress: 640, length: 640&#125;]//空闲的分区 因为首先由640的空间function free(Progress)//释放过程function FirstFit(Progress)//首次适应算法 申请function BestFit(Progress)//最佳适应算法 申请 一共有 7 个作业，所以我们这里需要先定义一个作业类，然后创建 7 个作业对象 12345678910111213141516function PCB(ID, firstAddress, length, lastAddress, flag) &#123; this.ID = ID //进程的ID this.firstAddress = firstAddress //进程的首地址 this.length = length //进程的长度 this.lastAddress = lastAddress //进程的末地址 this.flag = flag //是否使用&#125;//定义七个进程 这里首地址都是0，因为没分配let one = new PCB(1, 0, 130, 0, &apos;false&apos;)let two = new PCB(2, 0, 60, 0, &apos;false&apos;)let three = new PCB(3, 0, 100, 0, &apos;false&apos;)let four = new PCB(4, 0, 200, 0, &apos;false&apos;)let five = new PCB(5, 0, 140, 0, &apos;false&apos;)let six = new PCB(6, 0, 60, 0, &apos;false&apos;)let seven = new PCB(7, 0, 50, 0, &apos;false&apos;) 先编写一个有用的排序算法，后面会用的到，是利用一个对象中的某个属性进行排序 12345function sortlastAddressy(field) &#123; return function(a, lastAddress) &#123; return a[field] - lastAddress[field]; &#125;&#125; 这里实现首次适应算法 Progress 就是指各个作业 比如 one 作业 上面已经定义了，每次进入一个作业首先对空闲队列里面的空间进行排序(按照首地址排，并不是按照空间的大小排序，按照空间大小排那就是最佳适应算法了)。然后对空闲队列进行遍历，找到第一个适应 Progress 长度的空间，然后分配给它。里面的各个参数我进入代码给你们解释，看代码！ 12345678910111213141516171819202122232425262728293031function FirstFit(Progress) &#123; Progress.flag = &quot;true&quot; let d //它用来记录每次是空闲区间中哪一块被使用，记录它的末地址 freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;));//利用首地址排序， for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break;//找到以后就退出循环，不在遍历 找到了还遍历个逑啊 &#125; &#125; /* firstaddress 是我在全局定义的一个变量，用来记录每次在空闲去 生成空闲块的首地址 比如200-400的空闲 然后作业需要100空间，这里的Progress.firstAddress都是0，因为没有 被分配，所以都是0，那么firstaddress=100 ，分配以后，剩下的空闲块的首地址就是100了 */ firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress)//当作业被申请以后，就要进入占用空间 /*定义空闲块的末地址，也就是被使用的空闲块的末地址，200-400 被占用100以后 400还是是末地址 剩下的就是300-400的空闲块/* let lastAddress = d let length = lastAddress - firstAddress //每次分配作业以后就把 空闲块装进空闲空间 freeQueue.push(&#123; firstAddress, lastAddress, length, &#125;)&#125; 这里实现最佳适应算法 这里和首次适应算法的流程一样，区别就是排序的时候，这里是使用长度排序，而不是首地址空闲区里面第一个就是长度就短了，那么每次遍历只需要从头开始，找到第一个适合自己的，就是那个最适合自己的空间，然后退出，发现自己太聪明了。 12345678910111213141516171819202122function BestFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;length&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125; 这里实现释放算法 每次释放，作业就不是调用状态，就把它的状态改为 false详细解析看代码 12345678910111213141516171819function free(Progress) &#123; Progress.flag = &apos;false&apos; //找到要释放的作业的位置 let index = UseQueue.indexOf(Progress) //把该作业删除 UseQueue.splice(index, 1) /* 同时记录该作业的首地址，末地址，长度 因为他们释放以后，他们占用的空间就会变成空闲的，把该空闲块放到空闲空间中 */ let firstAddress = Progress.firstAddress let lastAddress = Progress.firstAddress + Progress.length let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125; 这里实现对空闲空间的操作 里面的内容众多 for 循环，你先看的话，你肯定不明白什么意思，这里给你说下它的功能你就知道它的代码意思 。这里是因为空闲空间的要求，需要对空间内的碎片进行整合比如空闲空间有两个空闲块 分别是 100-200 200-300 你发现 第一块的末地址与第二块的首地址相同，你就需要把它们合并成为 100-300，这就就剩下一个长度为 200 的大的空闲块同时如果是 100-400 300-400 这样的空闲块 你需要把第一块给删除了，因为 100-300 被使用。这样就只剩下 300-400 一块空闲。 123456789101112131415161718192021222324252627282930function dealFreequeue(freeQueue) &#123; if (freeQueue.length &gt; 1) &#123; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].lastAddress &amp;&amp; i != j) &#123; if (freeQueue[i].firstAddress &gt; freeQueue[j].firstAddress) &#123; freeQueue.splice(j, 1) &#125; else &#123; freeQueue.splice(i, 1) &#125; &#125; &#125; &#125; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].firstAddress &amp;&amp; freeQueue[i] != undefined) &#123; freeQueue[i].lastAddress = freeQueue[j].lastAddress freeQueue[i].length = freeQueue[i].lastAddress - freeQueue[i].firstAddress freeQueue.splice(j, 1) break; &#125; &#125; &#125; &#125; freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); return freeQueue&#125; 定义七个作业的执行数组 index=1 表示作业申请 index=-1 表示作业释放 12345678910111213141516171819202122232425262728293031323334353637let runqueue = [&#123; index: 1, Progress: one &#125;, &#123; index: 1, Progress: two &#125;, &#123; index: 1, Progress: three &#125;, &#123; index: -1, Progress: two &#125;, &#123; index: 1, Progress: four &#125;, &#123; index: -1, Progress: three &#125;, &#123; index: -1, Progress: one &#125;, &#123; index: 1, Progress: five &#125;, &#123; index: 1, Progress: six &#125;, &#123; index: 1, Progress: seven &#125;, &#123; index: -1, Progress: six &#125;] 实现展示界面 1234567891011function show(freeQueue) &#123; let str = &quot;&quot; let str1 = &quot;&quot;; for (item of freeQueue) &#123; str = item.firstAddress + &quot; &quot; + item.lastAddress + &quot; &quot; + item.length + &quot;\n&quot; str1 += str &#125; console.log(&quot;首地址 末地址 长度&quot;) console.log(str1)&#125; 实现首次适应算法的执行函数 12345678910111213141516171819function FirstFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) FirstFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空闲的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125; 实现最佳适应算法的执行函数 1234567891011121314151617function BestFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) BestFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空间的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125; 调用函数 不使用哪一个算法，就把它注释掉 12//FirstFitMain(runqueue)BestFitMain(runqueue) 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/* * @Author: mikey.zhaopeng * @Date: 2018-12-08 00:20:04 * @Last Modified by: mikey.zhaopeng * @Last Modified time: 2018-12-08 00:20:04 */function PCB(ID, firstAddress, length, lastAddress, flag) &#123; this.ID = ID //进程的ID this.firstAddress = firstAddress //进程的首地址 this.length = length //进程的长度 this.lastAddress = lastAddress //进程的末地址 this.flag = flag //是否使用&#125;//定义七个进程let one = new PCB(1, 0, 130, 0, &apos;false&apos;)let two = new PCB(2, 0, 60, 0, &apos;false&apos;)let three = new PCB(3, 0, 100, 0, &apos;false&apos;)let four = new PCB(4, 0, 200, 0, &apos;false&apos;)let five = new PCB(5, 0, 140, 0, &apos;false&apos;)let six = new PCB(6, 0, 60, 0, &apos;false&apos;)let seven = new PCB(7, 0, 50, 0, &apos;false&apos;)let freeQueue = [&#123; firstAddress: 0, lastAddress: 640, length: 640&#125;]let UseQueue = []let firstAddress = 0 //function sortlastAddressy(field) &#123; return function(a, lastAddress) &#123; return a[field] - lastAddress[field]; &#125;&#125;function FirstFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length, &#125;)&#125;function free(Progress) &#123; Progress.flag = &apos;false&apos; let index = UseQueue.indexOf(Progress) UseQueue.splice(index, 1) let firstAddress = Progress.firstAddress let lastAddress = Progress.firstAddress + Progress.length let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125;function BestFit(Progress) &#123; Progress.flag = &quot;true&quot; let d freeQueue.sort(sortlastAddressy(&quot;length&quot;)); for (let i = 0; i &lt; freeQueue.length; i++) &#123; if (freeQueue[i].length &gt; Progress.length) &#123; Progress.firstAddress = freeQueue[i].firstAddress d = freeQueue[i].lastAddress break; &#125; &#125; firstAddress = Progress.firstAddress + Progress.length Progress.lastAddress = Progress.firstAddress + Progress.length UseQueue.push(Progress) let lastAddress = d let length = lastAddress - firstAddress freeQueue.push(&#123; firstAddress, lastAddress, length &#125;)&#125;let runqueue = [&#123; index: 1, Progress: one &#125;, &#123; index: 1, Progress: two &#125;, &#123; index: 1, Progress: three &#125;, &#123; index: -1, Progress: two &#125;, &#123; index: 1, Progress: four &#125;, &#123; index: -1, Progress: three &#125;, &#123; index: -1, Progress: one &#125;, &#123; index: 1, Progress: five &#125;, &#123; index: 1, Progress: six &#125;, &#123; index: 1, Progress: seven &#125;, &#123; index: -1, Progress: six &#125;]function dealFreequeue(freeQueue) &#123; if (freeQueue.length &gt; 1) &#123; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].lastAddress &amp;&amp; i != j) &#123; if (freeQueue[i].firstAddress &gt; freeQueue[j].firstAddress) &#123; freeQueue.splice(j, 1) &#125; else &#123; freeQueue.splice(i, 1) &#125; &#125; &#125; &#125; for (let i = 0; i &lt; freeQueue.length; i++) &#123; for (let j = 0; j &lt; freeQueue.length; j++) &#123; if (freeQueue[i].lastAddress == freeQueue[j].firstAddress &amp;&amp; freeQueue[i] != undefined) &#123; freeQueue[i].lastAddress = freeQueue[j].lastAddress freeQueue[i].length = freeQueue[i].lastAddress - freeQueue[i].firstAddress freeQueue.splice(j, 1) break; &#125; &#125; &#125; &#125; freeQueue.sort(sortlastAddressy(&quot;firstAddress&quot;)); return freeQueue&#125;function FirstFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) FirstFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空闲的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125;function BestFitMain(runqueue) &#123; for (item of runqueue) &#123; console.log(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) if (item.index == 1) &#123; console.log(&quot;申请--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;长度:&quot;, item.Progress.length) BestFit(item.Progress) &#125; else &#123; console.log(&quot;释放--------&gt;&quot;, &quot;ID:&quot;, item.Progress.ID, &quot;首地址:&quot;, item.Progress.firstAddress, &quot;长度:&quot;, item.Progress.length) free(item.Progress) &#125; freeQueue = dealFreequeue(freeQueue) console.log(&quot;空间的空间:&quot;) show(freeQueue) console.log(&quot;已被占用的空间:&quot;) console.log(UseQueue) &#125;&#125;function show(freeQueue) &#123; let str = &quot;&quot; let str1 = &quot;&quot;; for (item of freeQueue) &#123; str = item.firstAddress + &quot; &quot; + item.lastAddress + &quot; &quot; + item.length + &quot;\n&quot; str1 += str &#125; console.log(&quot;首地址 末地址 长度&quot;) console.log(str1)&#125;//FirstFitMain(runqueue)BestFitMain(runqueue) 给大家看下结果，这里就截几个图，并不是全部结果，就前三个]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现字符串中的第一个唯一字符]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 代码：这道题读完以后就应该知道，这道题的时间复杂度最小也是 O(n),因为只要遍历玩整个字符串你才能知道那个字符串才是第一个不重复的字符串。思路：不存在返回-1 存在返回对应索引，那么就先把这二种情况分开：1 第一种 不存在返回 0 分为二种 空字符串 “” 和 “aabb” 空字符串在算法的开始进行一次判断就可以解决。第二种“aabb” 我们把它归到第二种情况下进行判断。2 第二种，我们只需设置一个对象 hashObj 在遍历字符串的时候，判断 hashObj 里面是否存在这个字符，如果不存在，就把这个位置的索引+1 放进去(为什么是加 1 因为第一个字符肯定不存在对象中，那么对象就会保存 0 这个索引，然而索引 0 在下一次判断的时候 Boolean 会把它转换为 fasle，那么他就会不存在，那么这个字符就会被重新赋值)如果存在就把该位置的值改为-2(-2 或者其他都行，-2 在这里只是表示这个字符重复的标志而已，但是那些会让判断变为 false 的值不可以)。遍历结束以后，这时候对 hashObj 进行遍历，找到第一个不是-2 的值 ，返回该值就是索引12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function(s) &#123; let hashObj = &#123;&#125; let b //存入索引 if (s == &quot;&quot;) &#123; b = -1 &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (hashObj[s[i]] &amp;&amp; hashObj[s[i]] != -2) &#123; hashObj[s[i]] = -2 &#125; else if (hashObj[s[i]] != -2) &#123; hashObj[s[i]] = i + 1 &#125; &#125; for (let item in hashObj) &#123; if (hashObj[item] != -2) &#123; b = (hashObj[item]) - 1 break; &#125; else &#123; b = -1 &#125; &#125; return b&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现买股票的最佳时机]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 123456789101112131415161718示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 买卖股票问题就是典型的动态规划问题。把大问题分解成小问题，小问题的最优解求出来，合并就是大问题的最优解。这道题的小问题就是比较相邻两天的股票的高低，后面的一天比前面的一天股票高，我们就买出，这样就能赚到钱，把所有的问题都归结于二天股票高低，这样问题就很容易理解，我们可以举个例子123456输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出,这笔交易所能获得利润 = 6-3 = 3 。 关于这道题，要想解答出来我们首先需要搞清楚规则。买股票想要获取最大利润，那么我们首先需要先检查数组中第一个数字，也就是说第一天的价格是 7，第二天价格是 1，很明显我们不会在最贵的时候买股票。所以我们最开始在第二天买，也就是价格等于 1 的时候买，第三天价格变成了 5，说明有钱赚了，那么就马上卖掉。这时候利润就是=5-1=4然后我们在第四天价格等于 3 的时候买股票，第五天价格等于 6，有钱赚，那么就马上卖掉即可。这时候利润就是=6-3=3总利润就是 4+3=7 由此我们可以得出结论，当明天的价格比今天的价格贵的时候我们今天买，明天卖，这样能够获取最大利润。搞清楚这个，相信你对上面的算法就一目了然了 最简单的公式就是 0-1+5-3+6=7 当后者比前面大，我们就加，反之我们就减，最后没有-4 的原因是，减去以后就不是最大利润。最前面的 0 我们可以理解问我们没有钱，然后欠钱买第二天的股票。1234567let max = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; max += (prices[i + 1] - prices[i]) &#125; &#125; return max 我看啦很多网上的文章，思路都是我这样，我在写这篇博客的时候，就陷入误区，就是买股票的钱是从哪里来的？难道不是从利润中减去的吗？比如上面的那个例子:7 1 5 3 6 4我们在第二天花一元买了彩票，在第三天五块抛出，这时候你手里有五元，利润是 5-1=4。但是你还需要买这天的股票(这时候需要比较这天(抛出的这天)和它后面的那天的大小，如果他小，就买，大的话就别买)。你发现今天是五元明天确实三元，所以你就明天买，今天不买。因为你手里有 5 元，买下 3 元以后，你还有 2 元，然后在 6 元的那天抛出，这时候你手里的前一共是 6+2=8 元！因为你最开始买彩票花了 1 元，减去 1–&gt;8-1=7 元上面的那个问题是我在写博客的时候发现的，顿时就陷入误区，同时又是在写的过程中发现如何解决的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现移动零]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明12必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 首先循环这个数组，将数组中所有不是 0 的数字，拿出来放到数组前面123456let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; 因为要保持原数组非零元素的相对顺序，所以每当遇到一个不为 0 的变量都要进行复制！最后遍历结束，那么会有 K 个不为 0 的变量，随后的 nums.length-K 的长度都是 0下面是详细代码123456789101112var moveZeroes = function(nums) &#123; let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; for (let j = k; j &lt; nums.length; j++) &#123; nums[j] = 0; &#125; return nums&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现有效的字母异位词]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 112输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 212输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 方法 1 类似哈希(还是重复问题)首先需要明白题的意思，其实就是比较两个字符串中字母是否相同，在相同的情况下比较该字符的数目是否相等。函数中先判断两个字符串的长度是否相等，不相等，直接返回 false 就不需要进行下面的操作定义两个对象,对象里面的变量格式在这里我就表示一下啊 哈1let obj=&#123;A:a&#125; 分别对两个字符串进行遍历(O(n)的时间复杂度)，如果对象不存在，则添加该单个字符，并将它的数值设置为 1。存在的话，就把他的数值加 1将对象转换为数组，进行数组长度的循环(这里为什么要把对象转换为数组，其实就是得到他的长度啊 哈)然后对数组进行遍历，然后将两个对象内对应数组遍历的值，进行比较。如果他们不同(说明某个字符，在两个字符串中出现的长度并不相等)直接返回 false12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; if (s.length != t.length) &#123; return false &#125; else if (s.length == 0 &amp;&amp; t.length == 0) &#123; return true &#125; else &#123; let sObj = &#123;&#125; let tObj = &#123;&#125; for (let i = 0; i &lt; s.length; i++) &#123; if (sObj[s[i]]) &#123; sObj[s[i]]++ &#125; else &#123; sObj[s[i]] = 1 &#125; &#125; for (let i = 0; i &lt; t.length; i++) &#123; if (tObj[t[i]]) &#123; tObj[t[i]]++ &#125; else &#123; tObj[t[i]] = 1 &#125; &#125; let arr = Object.keys(tObj) for (let i = 0; i &lt; arr.length; i++) &#123; if (tObj[arr[i]] != sObj[arr[i]]) &#123; return false &#125; &#125; return true &#125;&#125;; 方法 2 排序sort 方法可以对字符按照编码排序123d,c,b,a排完序以后a,b,c,d 思路很简单哦：先把字符串是 s,t 用字符串转换为数组 a,b(split 怎么用，自己看 API)。然后先看他们长度一样不，不一样就没必要进行下面的操作。一样的话，就对他们进行排序，排完序。a 和 b 两个数组是相等的(不是相同因为，内存地址不同)。那么进行循环，相同位置上的数它们都应该相等。不相等直接返回 false12345678910111213141516var isAnagram = function(s, t) &#123; let a = s.split(&quot;&quot;) let b = t.split(&quot;&quot;) if (a.length == b.length) &#123; a.sort() b.sort() for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] != b[i]) &#123; return false &#125; &#125; return true &#125; return false&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现从排序数组中删除重复项]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 112345给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 212345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法 1指针法，这种方法很容易理解。在函数中我定义了一个变量 i，它的初始位置是在 0，而后它与后面的元素进行比较，如果他与后面的元素不相同，那里指针指向下一位，然后在于比较的元素进行换位。如果相同，则定义一个变量来记录数量。当 for 循环结束以后，整个数组后面的 k 个元素全是重复的元素，那么把它们删除得到的数组就是所要求的数组12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if(nums.length==0) return 0; let i=0; let k=0; for(let j=1;j&lt;nums.length;j++) &#123; if(nums[j]!=nums[i]) &#123; i++; nums[i]=nums[j]; &#125; else &#123;k++&#125; &#125; nums.splice(nums.length-k,k) return i+1&#125;; 解法 2利用对象，hash。在遍历数组的时候，如果对象中不存在该数值，就把该数值存放带对象中，并且将元素添加到新数组中，如果存在，则直接跳过12345678910let arr = [] let hash = &#123;&#125; for (let i = 0; i &lt; nums.length; i++) &#123; if (!hash[nums[i]]) &#123; hash[nums[i]] = true arr.push(nums[i]) &#125; &#125; return arr;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现加一]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路：这道题我遇到的时候，我想到的第一个方法居然不是用算法，而是采用将数组转换为字符串，然后将字符串转换为数字然后进行加一操作。最后在反过来转换为数组首先讲这样的方法是肯定正确的，而且思路很清晰，但是它脱离的算法的根本，而且它有一个致命的缺点就是不能对包含很多元素的数组进行操作，这样会报错，它只能对小数组进行操作，那肯定是不符合题意的。随后我就上网找了关于这题的答案，不过网上给出的解析很模糊。我大概看了一下就把他们的想法给实现啦：首先数字加一会产生二种情况：1 数字不会产生进位 2 数字会产生进位（这里的进位是包含 9999+1=10000） 首先将 9999+1=10000 这种特殊情况给特殊对待，下面是代码：12345678910111213141516let index = 0; let arr = [] let len = digits.lengthfor (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; 这里数组会产生增加一位，所以我新建一个数组，来满足要求，第一种情况完成，这时候我们来分析第二种：这里会有二种：1+2=3(只是举个例子) 和 9+1=10(这个是进位的唯一情况)前者问题很好解决，只是单纯的在数组该位置的元素加一就可以，这时候就可以直接结束循环 。9+1=10 这种会进位 那么原数组的位置 10 就会变成 0 也就是(array[i]%10) 而且 array[i-1]会加一 这时候又会继续刚才的判断 1+2=3 或者 9+1=10；也就是只有遇到 9+1 的时候才会对数组元素继续遍历，下面是代码：1234567891011121314151617else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125; 详细代码 JS 实现1234567891011121314151617181920212223242526272829303132333435363738var plusOne = function(digits) &#123; let index = 0; let arr = [] let len = digits.length for (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125;&#125;;let arr = [2, 4, 9, 3, 9]let a = plusOne(arr)console.log(a)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现只出现一次的数字]]></title>
    <url>%2F2018%2F12%2F07%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 1234567示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 解法 1 暴力破解暴力破解的前提是你的数组是有序的，不是有序的，你遍历整个数组，你是无法进行比较的。在函数的开始，我就使用 JS 自带的 sort 排序进行排序(sort 使用的是插入排序和快速排序结合的排序算法。数组长度不超过 10 时，使用插入排序。长度超过 10 使用快速排序。在数组较短时插入排序更有效率。)遍历时候的时间复杂度是 O(lgN)的。比较，就需要比较前面一个和后面一个。这样更加准确，只要二者都不相同，那么肯定就是它了(for 里面是 i+2 的操作)暴力肯定不是最优解，如果数组中有一万个变量呢，排序都是一个大问题。12345678910var singleNumber = function(nums) &#123;let len = nums.length; nums = nums.sort((x, y) =&gt; x - y); if (nums[0] != nums[1]) return nums[0]; if (nums[len - 1] != nums[len - 2]) return nums[len - 1]; for (let i = 2; i &lt; len - 2; i += 2) &#123; if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) return nums[i];&#125; &#125; 解法 2 去重法 利用 JS 的 Set 方法这个思路就很简单，如果不存在就往里面放该数值，如果再次出现就删除！有限制—重复的元素必须是出现二次，不能是奇数次(3 次的话，不存在添加，存在删除，不存在添加)就会有大问题。最后 Set 里面只会剩下一个值，那个就是没有重复的数值。说实话，Set 取值(不知道数值的前提)是真的麻烦。如果能像数组那样，按照索引就好了。这里只好借助里面自带的循环，把数值取出来。123456789101112131415161718var singleNumber = function(nums) &#123; let hasObj = new Set() for (item of nums) &#123; if (hasObj.has(item)) &#123; hasObj.delete(item) &#125; else &#123; hasObj.add(item) &#125; &#125; let a hasObj.forEach(function(item) &#123; a = item &#125;); return a&#125;;let nums = [1, 1, 2, 2, 3, 3, 4]let a = singleNumber(nums)console.log(a) 解法 3 求差法思路：先对数组排序，显而易见的，单独出现一次的数据必然是出现在数组下标为偶数的位置（下标从 0 开始），那么所有奇数下标的元素之和减去偶数下标的元素之和，就是需要求得的结果。12345678var singleNumber = function(nums) &#123; nums.sort() let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = i % 2 == 0 ? sum + nums[i] : sum - nums[i] &#125; return sum&#125;; 解法 4 异或法根据异或运算的特点，相同的数字经过异或运算后结果为 0，除单独出现一次的数字外，其他数字都是出现两次的，那么这些数字经过异或运算后结果一定是 0。而任何数字与 0 进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案。其实严格来讲，只有第四种方式是题目想要的解法，其他三种方法都是有瑕疵的。也只有最后一种，时间复杂度是 O(n)空间复杂度 O(1)的。其他的二种有排序，时间复杂度不小，还一样 Set 需要额外的空间。列子： 1, 4, 2, 3, 2, 4, 1 对他们进行异或123456789最开始0的二级制表示为0000 0000，1的二进制表示为0000 00010000 0000 ^ 0000 0001 = 0000 0001//0和[1]进行异或获得的二进制转换成十进制就是1咯，把得到的1继续异或下面的数组0000 0001 ^ 0000 0100 = 0000 0101//1和[4]进行异或得到十进制数字是5，十进制没什么用了，我就不写了，继续异或0000 0101 ^ 0000 0010 = 0000 0111//0000 0111 ^ 0000 0011 = 0000 0100//0000 0100 ^ 0000 0010 = 0000 0110//0000 0110 ^ 0000 0100 = 0000 0010//0000 0010 ^ 0000 0001 = 0000 0011//最后就得到3了--------------------- 12345678var singleNumber = function(nums) &#123; let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = sum ^ nums[i] &#125; return sum&#125;; 对于最后一种方法，建议大家再去了解一下 JS 那些位运算。虽然数学上可能用的多，JS 上并没有大幅文字来讲解，但不代表它不重要。既然出现，就一定有使用它们的机会。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现 使用动态优先权的进程调度算法模拟]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[实验目的 通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。 实验内容（1）用 C 语言来实现对 N 个进程采用动态优先权优先算法的进程调度。（2）每个用来标识进程的进程控制块 PCB 用结构来描述，包括以下字段： •••• 进程标识数 ID。•••• 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。•••• 进程已占用的 CPU 时间 CPUTIME。•••• 进程还需占用的 CPU 时间 ALLTIME。当进程运行完毕时，ALLTIME 变为 0。•••• 进程的阻塞时间 STARTBLOCK，表示当进程再运行 STARTBLOCK 个时间片后，将进入阻塞状态。•••• 进程被阻塞的时间 BLOCKTIME，表示已足赛的进程再等待 BLOCKTIME 个时间片后，将转换成就绪状态•••• 进程状态 START。•••• 队列指针 NEXT，用来将 PCB 排成队列。 （3）优先数改变的原则： •••进程在就绪队列中呆一个时间片，优先数加 1。•••进程每运行一个时间片，优先数减 3。 （4）假设在调度前，系统中有 5 个进程，它们的初始状态如下：1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY 详细的步骤和思路全部在代码注释中，保证你看一遍就知道代码的意思，阅读起来没有任何难度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170//定义一个PCB对象function PCB(ID, Priority, Cputime, Alltime, Startblock, BlockTime, state) &#123; this.ID = ID //进程ID this.Priority = Priority //进程优先级 this.Cputime = Cputime //进程已占用的事件 this.Alltime = Alltime //进程需要占用的时间 this.Startblock = Startblock //进程需阻塞时间 this.BlockTime = BlockTime //进程阻塞的时间 this.state = state //进程状态&#125;//定义五个进程let One = new PCB(0, 9, 0, 3, 2, 3, &quot;Start&quot;)let Two = new PCB(1, 38, 0, 3, -1, 0, &quot;Start&quot;)let Three = new PCB(2, 30, 0, 6, -1, 0, &quot;Start&quot;)let Four = new PCB(3, 29, 0, 3, -1, 0, &quot;Start&quot;)let Five = new PCB(4, 0, 0, 4, -1, 0, &quot;Start&quot;) //就绪队列let readyqueue = [] //阻塞队列let blockqueue = [] //临时队列，存储初始队列let tempqueue = [] //执行完的队列let overqueue = [] //定义一个数组(队列)readyqueue = [One, Two, Three, Four, Five] //正在进行的进程let runProgress = new PCB() // 就绪队列优先权排序 /** * Sort的排序是按照队列各个元素的Priority(也就是优先权排队的) * 每次排完以后，优先权最大的在数组后面，这样每次运行主程序只需要 * 将最后一个拿出来就是要被运行的进程 * */function Sort(start) &#123; //sort函数 里面自己写一个函数，用来比较对象内的属性(默认的sort往往是不能够使用的) function sortBy(field) &#123; return function(a, b) &#123; return a[field] - b[field]; &#125; &#125; start.sort(sortBy(&quot;Priority&quot;)); return start&#125;//定义一个展示的界面function showWindow(start) &#123; let str1 = &apos;&apos; let str2 = &apos;&apos; let str3 = &quot;&quot; let str4 = &quot;&quot; let str5 = &quot;&quot; let str6 = &quot;&quot; let str7 = &quot;&quot; for (let i = 0; i &lt; start.length; i++) &#123; str1 = str1 + &quot; &quot; + start[i].ID; str2 = str2 + &quot; &quot; + start[i].Priority; str3 = str3 + &quot; &quot; + start[i].Cputime; str4 = str4 + &quot; &quot; + start[i].Alltime; str5 = str5 + &quot; &quot; + start[i].Startblock; str6 = str6 + &quot; &quot; + start[i].BlockTime; str7 = str7 + &quot; &quot; + start[i].state; &#125; console.log(&quot;------------------------------------------------&quot;) console.log(&quot;| ID &quot; + str1 + &quot; |&quot;) console.log(&quot;| Priority &quot; + str2 + &quot; |&quot;) console.log(&quot;| Cputime &quot; + str3 + &quot; |&quot;) console.log(&quot;| AllTime &quot; + str4 + &quot; |&quot;) console.log(&quot;| StackBlock &quot; + str5 + &quot; |&quot;) console.log(&quot;| BlockTime &quot; + str6 + &quot; |&quot;) console.log(&quot;| State &quot; + str7 + &quot; |&quot;) console.log(&quot;#################################################&quot;) showID(&quot;blockqueue&quot;, blockqueue) showID(&quot;overqueue&quot;, overqueue) console.log(&quot;------------------------------------------------&quot;)&#125;function showID(str1, arr) &#123; let str = &quot;&quot; for (let i = 0; i &lt; arr.length; i++) &#123; str += &quot; &quot; + arr[i].ID &#125; console.log(str1 + &quot;里面的进程有:&quot; + str)&#125;//阻塞队列更新/** * 阻塞队列的更新一共有两个参数，因为阻塞中的进程，如果他的阻塞时间(BlockTime)等于0 * 意味着它的阻塞时间已经到了，就需要到就绪队列中 * 进入就绪队列以后就要对就绪队列进行重新排序找出优先权最大的那个 */function blockqueueUpdata(blockqueue, readyqueue) &#123; if (blockqueue.length != 0) &#123; for (item of blockqueue) &#123; item.BlockTime-- if (item.BlockTime == 0) &#123; readyqueue.push(item) blockqueue.pop() readyqueue = Sort(readyqueue) break; &#125; &#125; &#125;&#125;//就绪队列更新/** * 对就绪队列的更新，需要明白最后一个进程是不能更新的 * 因为最后一个进程是优先权最大的那个，那个进程是正在运行的进程，严格意义上说它不算是就绪队列的 * 所以我们只需要对除了最后一个元素的其他元素进行优先权+1的操作 */function readyqueueUpdata(readyqueue) &#123; for (let i = 0; i &lt;= readyqueue.length - 2; i++) &#123; readyqueue[i].Priority++ &#125;&#125;//index记录运行个时间片let index = 0 //运行一个时间片function run(readyqueue) &#123; readyqueue = Sort(readyqueue) //运行之前 先对就绪队列排序 console.log(&quot;第&quot; + index + &quot;次&quot;) //这个地方展示的结果是每次运行前的结果，变化后的结构在下一次展示中能看到 showWindow(readyqueue) /*** * 每运行一次 正在运行的进程的优先权-3 所需时间片-1 已占用CPU时间+1 */ readyqueue[readyqueue.length - 1].Priority -= 3 readyqueue[readyqueue.length - 1].Alltime -= 1 readyqueue[readyqueue.length - 1].Cputime += 1 //运行完以后需要对就绪队列和阻塞队列进行更新 readyqueueUpdata(readyqueue) blockqueueUpdata(blockqueue, readyqueue) /*每次运行都需要把运行进程的的Startblock-1 Startblock=n表示 该进程在运行n个时间片就会进入阻塞队列 */ readyqueue[readyqueue.length - 1].Startblock -= 1 /*查看就绪队列最后一个(也就是刚刚执行完的优先权最大的那个进程) 他的时间片是否已经运行完了，如果他的Alltime==0 意味着它 运行结束，就可以进入结束队列，不需要在就绪队列呆着(不需要 进行任何操作，其他进程运行与它无关) */ if (readyqueue[readyqueue.length - 1].Alltime == 0) &#123; console.log(readyqueue[readyqueue.length - 1].ID) readyqueue[readyqueue.length - 1].state = &quot;Finish&quot; overqueue.push(readyqueue.pop()) &#125; // 谁的StartBlock==0 就意味该进程需要进入阻塞队列，不能在就绪队列呆着 //因为每次对StartBlock-1 都是对就绪队列最后一个进行操作，所以这个只需要比较最后一个 if (readyqueue.length &gt; 0) &#123; if (readyqueue[readyqueue.length - 1].Startblock == 0) &#123; readyqueue[readyqueue.length - 1].state = &quot;Block&quot; blockqueue.push(readyqueue.pop()) &#125; &#125; readyqueue = Sort(readyqueue) index++&#125;//主函数 k的取值我是随便选的 主要判断就是readyqueue.length//如果等于0就结束操作，你这k 可以为任何值(需要和while一样就行)function main(readyqueue) &#123; let k = 0 while (k &lt; 5) &#123; run(readyqueue) k = 0 if (readyqueue.length == 0) &#123; k = 5 &#125; &#125;&#125;main(readyqueue)]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现存在重复]]></title>
    <url>%2F2018%2F12%2F05%2FJS%E5%AE%9E%E7%8E%B0LeetCode%E7%AE%97%E6%B3%95%2F%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 方法 1 排序后循环遍历先对数组进行排序，然后如果存在重复的数值，那么这几个数值一定是在一起的，也就是连续的，遍历的时候，只需要对该位置和该位置的后一个位置的数值进行比较就可以，两者相等，那么直接返回 true。遍历结束不存在，则返回 false12345678var containsDuplicate = function(nums) &#123; nums.sort() for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i + 1]) &#123; return true &#125; &#125; return false&#125;; 方法 2 哈希表哈希表特性我就不啰嗦，思路老套路：不存在就向表中存数据，存在返回值其实总结一些算法题：存在重复字眼的。都离不开哈希表(我说大多数啊 哈 毕竟我做的也不是很多啊。)考虑一下也无妨啊，搞不好一下子就出来了呢？123456789101112var containsDuplicate = function(nums) &#123; let hasObj = new Map() for (item of nums) &#123; if (hasObj.has(item)) &#123; return true &#125; else &#123; hasObj.set(item) &#125; &#125; return false&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
</search>
