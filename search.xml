<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS实现加一]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路：这道题我遇到的时候，我想到的第一个方法居然不是用算法，而是采用将数组转换为字符串，然后将字符串转换为数字然后进行加一操作。最后在反过来转换为数组首先讲这样的方法是肯定正确的，而且思路很清晰，但是它脱离的算法的根本，而且它有一个致命的缺点就是不能对包含很多元素的数组进行操作，这样会报错，它只能对小数组进行操作，那肯定是不符合题意的。随后我就上网找了关于这题的答案，不过网上给出的解析很模糊。我大概看了一下就把他们的想法给实现啦：首先数字加一会产生二种情况：1 数字不会产生进位 2 数字会产生进位（这里的进位是包含 9999+1=10000） 首先将 9999+1=10000 这种特殊情况给特殊对待，下面是代码：12345678910111213141516let index = 0; let arr = [] let len = digits.lengthfor (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; 这里数组会产生增加一位，所以我新建一个数组，来满足要求，第一种情况完成，这时候我们来分析第二种：这里会有二种：1+2=3(只是举个例子) 和 9+1=10(这个是进位的唯一情况)前者问题很好解决，只是单纯的在数组该位置的元素加一就可以，这时候就可以直接结束循环 。9+1=10 这种会进位 那么原数组的位置 10 就会变成 0 也就是(array[i]%10) 而且 array[i-1]会加一 这时候又会继续刚才的判断 1+2=3 或者 9+1=10；也就是只有遇到 9+1 的时候才会对数组元素继续遍历，下面是代码：1234567891011121314151617else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125; 详细代码 JS 实现1234567891011121314151617181920212223242526272829303132333435363738var plusOne = function(digits) &#123; let index = 0; let arr = [] let len = digits.length for (i of digits) &#123; if (i != 9) &#123; break; &#125; index++; &#125; if (index == digits.length) &#123; arr[0] = 1; for (let j = 0; j &lt; digits.length; j++) &#123; arr.push(0) &#125; return arr; &#125; else &#123; let carry = 0; digits[len - 1] += 1; for (i = len - 1; i &gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &gt;= 10) &#123; carry = digits[i] / 10; digits[i] = digits[i] % 10; &#125; else &#123; break; &#125; &#125; return digits &#125;&#125;;let arr = [2, 4, 9, 3, 9]let a = plusOne(arr)console.log(a)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现只出现一次的数字]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 1234567示例 1:输入: [2,2,1]输出: 1示例 2:输入: [4,1,2,1,2]输出: 4 解法 1 暴力破解暴力破解的前提是你的数组是有序的，不是有序的，你遍历整个数组，你是无法进行比较的。在函数的开始，我就使用 JS 自带的 sort 排序进行排序(sort 使用的是插入排序和快速排序结合的排序算法。数组长度不超过 10 时，使用插入排序。长度超过 10 使用快速排序。在数组较短时插入排序更有效率。)遍历时候的时间复杂度是 O(lgN)的。比较，就需要比较前面一个和后面一个。这样更加准确，只要二者都不相同，那么肯定就是它了(for 里面是 i+2 的操作)暴力肯定不是最优解，如果数组中有一万个变量呢，排序都是一个大问题。12345678910var singleNumber = function(nums) &#123;let len = nums.length; nums = nums.sort((x, y) =&gt; x - y); if (nums[0] != nums[1]) return nums[0]; if (nums[len - 1] != nums[len - 2]) return nums[len - 1]; for (let i = 2; i &lt; len - 2; i += 2) &#123; if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) return nums[i];&#125; &#125; 解法 2 去重法 利用 JS 的 Set 方法这个思路就很简单，如果不存在就往里面放该数值，如果再次出现就删除！有限制—重复的元素必须是出现二次，不能是奇数次(3 次的话，不存在添加，存在删除，不存在添加)就会有大问题。最后 Set 里面只会剩下一个值，那个就是没有重复的数值。说实话，Set 取值(不知道数值的前提)是真的麻烦。如果能像数组那样，按照索引就好了。这里只好借助里面自带的循环，把数值取出来。123456789101112131415161718var singleNumber = function(nums) &#123; let hasObj = new Set() for (item of nums) &#123; if (hasObj.has(item)) &#123; hasObj.delete(item) &#125; else &#123; hasObj.add(item) &#125; &#125; let a hasObj.forEach(function(item) &#123; a = item &#125;); return a&#125;;let nums = [1, 1, 2, 2, 3, 3, 4]let a = singleNumber(nums)console.log(a) 解法 3 求差法思路：先对数组排序，显而易见的，单独出现一次的数据必然是出现在数组下标为偶数的位置（下标从 0 开始），那么所有奇数下标的元素之和减去偶数下标的元素之和，就是需要求得的结果。12345678var singleNumber = function(nums) &#123; nums.sort() let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = i % 2 == 0 ? sum + nums[i] : sum - nums[i] &#125; return sum&#125;; 解法 4 异或法根据异或运算的特点，相同的数字经过异或运算后结果为 0，除单独出现一次的数字外，其他数字都是出现两次的，那么这些数字经过异或运算后结果一定是 0。而任何数字与 0 进行异或运算都是该数字本身。所以对数组所有元素进行异或运算，运算结果就是题目的答案。其实严格来讲，只有第四种方式是题目想要的解法，其他三种方法都是有瑕疵的。也只有最后一种，时间复杂度是 O(n)空间复杂度 O(1)的。其他的二种有排序，时间复杂度不小，还一样 Set 需要额外的空间。列子： 1, 4, 2, 3, 2, 4, 1 对他们进行异或123456789最开始0的二级制表示为0000 0000，1的二进制表示为0000 00010000 0000 ^ 0000 0001 = 0000 0001//0和[1]进行异或获得的二进制转换成十进制就是1咯，把得到的1继续异或下面的数组0000 0001 ^ 0000 0100 = 0000 0101//1和[4]进行异或得到十进制数字是5，十进制没什么用了，我就不写了，继续异或0000 0101 ^ 0000 0010 = 0000 0111//0000 0111 ^ 0000 0011 = 0000 0100//0000 0100 ^ 0000 0010 = 0000 0110//0000 0110 ^ 0000 0100 = 0000 0010//0000 0010 ^ 0000 0001 = 0000 0011//最后就得到3了--------------------- 12345678var singleNumber = function(nums) &#123; let sum = 0 for (let i = 0; i &lt; nums.length; i++) &#123; sum = sum ^ nums[i] &#125; return sum&#125;; 对于最后一种方法，建议大家再去了解一下 JS 那些位运算。虽然数学上可能用的多，JS 上并没有大幅文字来讲解，但不代表它不重要。既然出现，就一定有使用它们的机会。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现字符串中的第一个唯一字符]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 代码：这道题读完以后就应该知道，这道题的时间复杂度最小也是 O(n),因为只要遍历玩整个字符串你才能知道那个字符串才是第一个不重复的字符串。思路：不存在返回-1 存在返回对应索引，那么就先把这二种情况分开：1 第一种 不存在返回 0 分为二种 空字符串 “” 和 “aabb” 空字符串在算法的开始进行一次判断就可以解决。第二种“aabb” 我们把它归到第二种情况下进行判断。2 第二种，我们只需设置一个对象 hashObj 在遍历字符串的时候，判断 hashObj 里面是否存在这个字符，如果不存在，就把这个位置的索引+1 放进去(为什么是加 1 因为第一个字符肯定不存在对象中，那么对象就会保存 0 这个索引，然而索引 0 在下一次判断的时候 Boolean 会把它转换为 fasle，那么他就会不存在，那么这个字符就会被重新赋值)如果存在就把该位置的值改为-2(-2 或者其他都行，-2 在这里只是表示这个字符重复的标志而已，但是那些会让判断变为 false 的值不可以)。遍历结束以后，这时候对 hashObj 进行遍历，找到第一个不是-2 的值 ，返回该值就是索引12345678910111213141516171819202122232425262728/** * @param &#123;string&#125; s * @return &#123;number&#125; */var firstUniqChar = function(s) &#123; let hashObj = &#123;&#125; let b //存入索引 if (s == &quot;&quot;) &#123; b = -1 &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (hashObj[s[i]] &amp;&amp; hashObj[s[i]] != -2) &#123; hashObj[s[i]] = -2 &#125; else if (hashObj[s[i]] != -2) &#123; hashObj[s[i]] = i + 1 &#125; &#125; for (let item in hashObj) &#123; if (hashObj[item] != -2) &#123; b = (hashObj[item]) - 1 break; &#125; else &#123; b = -1 &#125; &#125; return b&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现有效的字母异位词]]></title>
    <url>%2F2018%2F12%2F07%2F%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 112输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 212输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 方法 1 类似哈希(还是重复问题)首先需要明白题的意思，其实就是比较两个字符串中字母是否相同，在相同的情况下比较该字符的数目是否相等。函数中先判断两个字符串的长度是否相等，不相等，直接返回 false 就不需要进行下面的操作定义两个对象,对象里面的变量格式在这里我就表示一下啊 哈1let obj=&#123;A:a&#125; 分别对两个字符串进行遍历(O(n)的时间复杂度)，如果对象不存在，则添加该单个字符，并将它的数值设置为 1。存在的话，就把他的数值加 1将对象转换为数组，进行数组长度的循环(这里为什么要把对象转换为数组，其实就是得到他的长度啊 哈)然后对数组进行遍历，然后将两个对象内对应数组遍历的值，进行比较。如果他们不同(说明某个字符，在两个字符串中出现的长度并不相等)直接返回 false12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isAnagram = function(s, t) &#123; if (s.length != t.length) &#123; return false &#125; else if (s.length == 0 &amp;&amp; t.length == 0) &#123; return true &#125; else &#123; let sObj = &#123;&#125; let tObj = &#123;&#125; for (let i = 0; i &lt; s.length; i++) &#123; if (sObj[s[i]]) &#123; sObj[s[i]]++ &#125; else &#123; sObj[s[i]] = 1 &#125; &#125; for (let i = 0; i &lt; t.length; i++) &#123; if (tObj[t[i]]) &#123; tObj[t[i]]++ &#125; else &#123; tObj[t[i]] = 1 &#125; &#125; let arr = Object.keys(tObj) for (let i = 0; i &lt; arr.length; i++) &#123; if (tObj[arr[i]] != sObj[arr[i]]) &#123; return false &#125; &#125; return true &#125;&#125;; 方法 2 排序sort 方法可以对字符按照编码排序123d,c,b,a排完序以后a,b,c,d 思路很简单哦：先把字符串是 s,t 用字符串转换为数组 a,b(split 怎么用，自己看 API)。然后先看他们长度一样不，不一样就没必要进行下面的操作。一样的话，就对他们进行排序，排完序。a 和 b 两个数组是相等的(不是相同因为，内存地址不同)。那么进行循环，相同位置上的数它们都应该相等。不相等直接返回 false12345678910111213141516var isAnagram = function(s, t) &#123; let a = s.split(&quot;&quot;) let b = t.split(&quot;&quot;) if (a.length == b.length) &#123; a.sort() b.sort() for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] != b[i]) &#123; return false &#125; &#125; return true &#125; return false&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现移动零]]></title>
    <url>%2F2018%2F12%2F07%2F%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明12必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 首先循环这个数组，将数组中所有不是 0 的数字，拿出来放到数组前面123456let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; 因为要保持原数组非零元素的相对顺序，所以每当遇到一个不为 0 的变量都要进行复制！最后遍历结束，那么会有 K 个不为 0 的变量，随后的 nums.length-K 的长度都是 0下面是详细代码123456789101112var moveZeroes = function(nums) &#123; let k = 0; for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] !== 0) &#123; nums[k++] = nums[i]; &#125; &#125; for (let j = k; j &lt; nums.length; j++) &#123; nums[j] = 0; &#125; return nums&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现从排序数组中删除重复项]]></title>
    <url>%2F2018%2F12%2F07%2F%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 112345给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 212345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解法 1指针法，这种方法很容易理解。在函数中我定义了一个变量 i，它的初始位置是在 0，而后它与后面的元素进行比较，如果他与后面的元素不相同，那里指针指向下一位，然后在于比较的元素进行换位。如果相同，则定义一个变量来记录数量。当 for 循环结束以后，整个数组后面的 k 个元素全是重复的元素，那么把它们删除得到的数组就是所要求的数组12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if(nums.length==0) return 0; let i=0; let k=0; for(let j=1;j&lt;nums.length;j++) &#123; if(nums[j]!=nums[i]) &#123; i++; nums[i]=nums[j]; &#125; else &#123;k++&#125; &#125; nums.splice(nums.length-k,k) return i+1&#125;; 解法 2利用对象，hash。在遍历数组的时候，如果对象中不存在该数值，就把该数值存放带对象中，并且将元素添加到新数组中，如果存在，则直接跳过12345678910let arr = [] let hash = &#123;&#125; for (let i = 0; i &lt; nums.length; i++) &#123; if (!hash[nums[i]]) &#123; hash[nums[i]] = true arr.push(nums[i]) &#125; &#125; return arr;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现买股票的最佳时机]]></title>
    <url>%2F2018%2F12%2F07%2F%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 123456789101112131415161718示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 买卖股票问题就是典型的动态规划问题。把大问题分解成小问题，小问题的最优解求出来，合并就是大问题的最优解。这道题的小问题就是比较相邻两天的股票的高低，后面的一天比前面的一天股票高，我们就买出，这样就能赚到钱，把所有的问题都归结于二天股票高低，这样问题就很容易理解，我们可以举个例子123456输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出,这笔交易所能获得利润 = 6-3 = 3 。 关于这道题，要想解答出来我们首先需要搞清楚规则。买股票想要获取最大利润，那么我们首先需要先检查数组中第一个数字，也就是说第一天的价格是 7，第二天价格是 1，很明显我们不会在最贵的时候买股票。所以我们最开始在第二天买，也就是价格等于 1 的时候买，第三天价格变成了 5，说明有钱赚了，那么就马上卖掉。这时候利润就是=5-1=4然后我们在第四天价格等于 3 的时候买股票，第五天价格等于 6，有钱赚，那么就马上卖掉即可。这时候利润就是=6-3=3总利润就是 4+3=7 由此我们可以得出结论，当明天的价格比今天的价格贵的时候我们今天买，明天卖，这样能够获取最大利润。搞清楚这个，相信你对上面的算法就一目了然了 最简单的公式就是 0-1+5-3+6=7 当后者比前面大，我们就加，反之我们就减，最后没有-4 的原因是，减去以后就不是最大利润。最前面的 0 我们可以理解问我们没有钱，然后欠钱买第二天的股票。1234567let max = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; max += (prices[i + 1] - prices[i]) &#125; &#125; return max 我看啦很多网上的文章，思路都是我这样，我在写这篇博客的时候，就陷入误区，就是买股票的钱是从哪里来的？难道不是从利润中减去的吗？比如上面的那个例子:7 1 5 3 6 4我们在第二天花一元买了彩票，在第三天五块抛出，这时候你手里有五元，利润是 5-1=4。但是你还需要买这天的股票(这时候需要比较这天(抛出的这天)和它后面的那天的大小，如果他小，就买，大的话就别买)。你发现今天是五元明天确实三元，所以你就明天买，今天不买。因为你手里有 5 元，买下 3 元以后，你还有 2 元，然后在 6 元的那天抛出，这时候你手里的前一共是 6+2=8 元！因为你最开始买彩票花了 1 元，减去 1–&gt;8-1=7 元上面的那个问题是我在写博客的时候发现的，顿时就陷入误区，同时又是在写的过程中发现如何解决的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2F%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现两个数组的交集]]></title>
    <url>%2F2018%2F12%2F06%2FJS%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明：12输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:123如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 方法一 利用 Map这个利用 Map 原因是，数组里面可能有重复元素，但是 Set 结构里面是不能有重复的元素。新建一个 res 来保存两个数组重叠的交集，在主函数中首先判断下谁的数组长度比较短，短的那一个为 Map 对象的复制体(如果两个数组的元素数目相差很多的话，优势就会体现出来，额外的空间就很少很多。你懂得！)Map 复制完以后，接下来的 for 循环就是遍历另一个数组.与 map 中的元素进行比较，相同的话，把元素从 map 中删除，同时把该元素放入我们的 res 数组中。在对 map 相减的时候，对 map 的长度进行判断，如果为 0，就提前结束循环(刚好他们重复的元素都在数组的前半部分呢？这样后面就可以不再遍历了，特殊情况下还是可以减少时间的)123456789101112131415161718192021222324252627282930313233 var intersect = function(nums1, nums2) &#123; let res = []; let map = &#123;&#125;; if (nums1.length &lt; nums2.length) &#123; for (let e of nums1) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums2) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; else &#123; for (let e of nums2) &#123; map[e] = map[e] + 1 || 1; &#125; for (let e of nums1) &#123; if (map[e]) &#123; res.push(e); map[e]--; if(map.size==0) &#123;break;&#125; &#125; &#125; &#125; return res;&#125;; 方法二 对两者进行排序，双指针移动法牵扯事先排序，那么该算法肯定不是最优先解，谁知道排序会占用多少时间呢？这里我们就把方法归结于暴力破解吧，虽然代码投机取巧，但是复杂度不小思路：排完序以后两个数组内的元素都是从小到大排列的，这时候用两个指针 i，j 来遍历数组。这里的 i，j 是指数组的索引，当数组中的两个都相同的，把该元素加入 arr 数组，然后两个指针都相加。相反，谁的值小，谁的指针移动(这就是为什我们要排序的目的)12345678910111213141516var intersect = function(nums1, nums2) &#123; nums1.sort((x, y) =&gt; x - y) nums2.sort((x, y) =&gt; x - y) let i = 0, j = 0; let arr = [] while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] == nums2[j]) &#123; arr.push(nums1[i]); i++; j++ &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++ &#125; else &#123; i++ &#125; &#125; return arr &#125;; 方法三 暴力破解(这个是真正的暴力破解)两个 for 循环解决，时间复杂度是真的高。面试遇到，你给面试官说个这个方法(并且你就知道这一种)嘿嘿，那么你的博客就会多上一篇凉凉面经！下面的代码没有测试，思路就是那样，不建议大家掌握这种，只会暴力，那还学算法干嘛1234567891011121314151617var intersect = function(nums1, nums2) &#123; let map = new Map() let arr = [] for (let i = 0; i &lt; nums1.length; i++) &#123; for (let j = 0; j &lt; nums2.length; j++) &#123; if (nums2[j] == nums1[i]) &#123; arr.push(nums1[i]) map.delete(nums1[i]) map.set(nums1[i]) break; //退出本次循环，找到重复的，后面再出现重复的，我也不会添加 &#125; &#125; &#125; return arr&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现存在重复]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 方法 1 排序后循环遍历先对数组进行排序，然后如果存在重复的数值，那么这几个数值一定是在一起的，也就是连续的，遍历的时候，只需要对该位置和该位置的后一个位置的数值进行比较就可以，两者相等，那么直接返回 true。遍历结束不存在，则返回 false12345678var containsDuplicate = function(nums) &#123; nums.sort() for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i + 1]) &#123; return true &#125; &#125; return false&#125;; 方法 2 哈希表哈希表特性我就不啰嗦，思路老套路：不存在就向表中存数据，存在返回值其实总结一些算法题：存在重复字眼的。都离不开哈希表(我说大多数啊 哈 毕竟我做的也不是很多啊。)考虑一下也无妨啊，搞不好一下子就出来了呢？123456789101112var containsDuplicate = function(nums) &#123; let hasObj = new Map() for (item of nums) &#123; if (hasObj.has(item)) &#123; return true &#125; else &#123; hasObj.set(item) &#125; &#125; return false&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>-LeetCode</tag>
      </tags>
  </entry>
</search>
